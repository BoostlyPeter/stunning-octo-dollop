<!DOCTYPE html>
<html lang="sv">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Dina SkÃ¤rgÃ¥rd â€“ Painted Archipelago</title>
<link rel="stylesheet" href="mockup-shared.css">
<style>
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
:root{--dk:#003e23;--pk:#50bb4e;--pg:#edf6ed;--gold:#d4a843;--ocean1:#1a7868;--ocean2:#228870;--ocean3:#2a9878;--panelw:380px}
html,body{width:100%;height:100%;overflow:hidden;font-family:'Segoe UI',system-ui,sans-serif;background:var(--ocean1)}
#topbar{position:fixed;top:0;left:0;right:0;height:52px;background:linear-gradient(135deg,var(--dk),#00562f);display:flex;align-items:center;padding:0 18px;z-index:900;box-shadow:0 2px 12px rgba(0,0,0,.5);gap:14px}
#topbar .logo{font-size:20px;font-weight:700;color:#fff;white-space:nowrap;letter-spacing:.5px}
#topbar .logo span{color:var(--pk)}
#topbar .era-banner{background:linear-gradient(90deg,rgba(212,168,67,.15),rgba(212,168,67,.3),rgba(212,168,67,.15));border:1px solid rgba(212,168,67,.4);border-radius:6px;padding:4px 16px;color:var(--gold);font-size:13px;font-weight:600;letter-spacing:1px;text-transform:uppercase;white-space:nowrap}
#topbar .search-wrap{flex:1;max-width:380px;margin-left:auto;position:relative}
#topbar .search-wrap input{width:100%;padding:7px 14px 7px 34px;border-radius:8px;border:1px solid rgba(255,255,255,.2);background:rgba(255,255,255,.1);color:#fff;font-size:14px;outline:none;transition:all .2s}
#topbar .search-wrap input::placeholder{color:rgba(255,255,255,.5)}
#topbar .search-wrap input:focus{background:rgba(255,255,255,.18);border-color:var(--pk)}
#topbar .search-wrap .search-icon{position:absolute;left:10px;top:50%;transform:translateY(-50%);color:rgba(255,255,255,.5);font-size:14px;pointer-events:none}
#topbar .user-avatar{width:34px;height:34px;border-radius:50%;background:var(--pk);display:flex;align-items:center;justify-content:center;color:#fff;font-weight:700;font-size:14px;cursor:pointer}
#map-container{position:fixed;top:52px;left:0;right:0;bottom:0;overflow:hidden;cursor:grab;background:radial-gradient(ellipse at 50% 50%,#3aaa90,#2a8a78 45%,#1a7868 85%)}
#map-container.grabbing{cursor:grabbing}
#map-svg{position:absolute;top:0;left:0;width:100%;height:100%;touch-action:none}

/* Compass */
#compass{position:fixed;top:64px;left:14px;z-index:800;width:72px;height:72px;pointer-events:none;opacity:.7}
#compass svg{width:100%;height:100%}

/* Minimap */
#minimap{position:fixed;top:64px;right:14px;width:200px;height:150px;background:rgba(20,100,80,.75);border:2px solid rgba(80,187,78,.4);border-radius:10px;z-index:800;overflow:hidden;cursor:pointer}
#minimap canvas{width:100%;height:100%}
#minimap .viewport-rect{position:absolute;border:1.5px solid var(--pk);pointer-events:none;border-radius:2px}

/* Legend */
#legend{position:fixed;bottom:14px;left:14px;background:rgba(240,250,240,.92);border:1px solid rgba(80,187,78,.35);border-radius:12px;padding:14px 16px;z-index:800;color:var(--dk);font-size:12px;min-width:170px;backdrop-filter:blur(6px);box-shadow:0 2px 10px rgba(0,40,20,.12)}
#legend h4{font-size:13px;margin-bottom:8px;color:#8a6a20;letter-spacing:.5px}
#legend .leg-item{display:flex;align-items:center;gap:8px;margin-bottom:5px}
#legend .leg-dot{width:14px;height:14px;border-radius:50%;flex-shrink:0}
#legend .leg-line{width:20px;height:0;border-top:2.5px dashed rgba(180,140,80,.7);flex-shrink:0}

/* Zoom controls */
#zoom-ctrl{position:fixed;bottom:14px;right:14px;display:flex;flex-direction:column;gap:4px;z-index:800}
#zoom-ctrl button{width:40px;height:40px;border:1px solid rgba(80,187,78,.35);background:rgba(240,250,240,.9);color:var(--dk);font-size:20px;border-radius:8px;cursor:pointer;display:flex;align-items:center;justify-content:center;backdrop-filter:blur(6px);transition:all .15s;box-shadow:0 2px 6px rgba(0,40,20,.1)}
#zoom-ctrl button:hover{background:rgba(80,187,78,.2);border-color:var(--pk)}

/* Detail panel */
#detail-panel{position:fixed;top:52px;right:0;bottom:0;width:var(--panelw);background:linear-gradient(180deg,#f5faf5 0%,#edf6ed 100%);border-left:2px solid var(--pk);z-index:850;transform:translateX(100%);transition:transform .35s cubic-bezier(.4,0,.2,1);overflow-y:auto;color:var(--dk);backdrop-filter:blur(10px)}
#detail-panel.open{transform:translateX(0)}
#detail-panel .dp-close{position:absolute;top:12px;right:14px;width:32px;height:32px;border-radius:50%;border:1px solid rgba(0,62,35,.15);background:transparent;color:var(--dk);font-size:18px;cursor:pointer;display:flex;align-items:center;justify-content:center}
#detail-panel .dp-close:hover{background:rgba(0,62,35,.08)}
#detail-panel .dp-header{padding:24px 20px 16px;border-bottom:1px solid rgba(0,62,35,.1)}
#detail-panel .dp-emoji{font-size:40px;margin-bottom:8px}
#detail-panel .dp-name{font-size:22px;font-weight:700;margin-bottom:4px}
#detail-panel .dp-type{font-size:12px;text-transform:uppercase;letter-spacing:1px;color:#fff;background:var(--pk);display:inline-block;padding:2px 10px;border-radius:20px;margin-bottom:4px}
#detail-panel .dp-terrain{font-size:11px;color:#5a7a5a;margin-top:4px}
#detail-panel .dp-desc{padding:16px 20px;font-size:13px;color:#3a5a3a;line-height:1.5;border-bottom:1px solid rgba(0,62,35,.1)}
#detail-panel .dp-stats{display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px;padding:16px 20px;border-bottom:1px solid rgba(0,62,35,.1)}
#detail-panel .dp-stat{text-align:center}
#detail-panel .dp-stat .val{font-size:22px;font-weight:700;color:var(--dk)}
#detail-panel .dp-stat .lbl{font-size:11px;color:#5a7a5a;margin-top:2px}
#detail-panel .dp-libs{padding:16px 20px;border-bottom:1px solid rgba(0,62,35,.1)}
#detail-panel .dp-libs h4{font-size:13px;margin-bottom:10px;color:var(--dk)}
#detail-panel .dp-lib{display:flex;align-items:center;gap:8px;padding:6px 0;font-size:13px}
#detail-panel .dp-lib .lib-icon{width:28px;height:28px;border-radius:6px;background:rgba(80,187,78,.12);display:flex;align-items:center;justify-content:center;font-size:14px;flex-shrink:0}
#detail-panel .dp-lib .lib-count{margin-left:auto;color:#5a7a5a;font-size:12px}
#detail-panel .dp-actions{padding:16px 20px;display:flex;flex-direction:column;gap:8px}
#detail-panel .dp-actions button{padding:10px 16px;border-radius:8px;border:none;font-size:13px;font-weight:600;cursor:pointer;transition:all .15s;display:flex;align-items:center;gap:8px;justify-content:center}
#detail-panel .dp-actions .btn-primary{background:var(--pk);color:#fff}
#detail-panel .dp-actions .btn-primary:hover{background:#45a843}
#detail-panel .dp-actions .btn-secondary{background:#fff;color:var(--dk);border:1px solid rgba(0,62,35,.2)}
#detail-panel .dp-actions .btn-secondary:hover{background:rgba(0,62,35,.05)}

/* Ship */
#ship{position:fixed;width:32px;height:32px;z-index:700;pointer-events:none;opacity:0;transition:opacity .3s}
#ship.sailing{opacity:1}
#ship svg{width:100%;height:100%}

/* Toast */
#toast{position:fixed;bottom:80px;left:50%;transform:translateX(-50%) translateY(30px);background:rgba(255,255,255,.95);color:var(--dk);padding:10px 22px;border-radius:10px;font-size:13px;opacity:0;pointer-events:none;z-index:999;border:1px solid var(--pk);transition:all .3s;white-space:nowrap;box-shadow:0 2px 12px rgba(0,40,20,.15)}
#toast.show{opacity:1;transform:translateX(-50%) translateY(0)}

/* Wave animation for water texture */
@keyframes waveShift{0%{transform:translateX(0)}100%{transform:translateX(60px)}}
@keyframes gentleWave{0%{transform:translateX(0) translateY(0)}50%{transform:translateX(30px) translateY(2px)}100%{transform:translateX(0) translateY(0)}}

/* Activity pulse */
@keyframes pulse{0%,100%{r:4;opacity:1}50%{r:7;opacity:.6}}

/* â”€â”€ Toolbar (edit mode / layout) â”€â”€ */
#toolbar{position:fixed;top:58px;left:50%;transform:translateX(-50%);z-index:810;display:flex;gap:6px;padding:6px 10px;background:rgba(240,250,240,.92);border:1px solid rgba(80,187,78,.35);border-radius:10px;backdrop-filter:blur(8px);font-size:12px;color:var(--dk);align-items:center;transition:all .3s;box-shadow:0 2px 10px rgba(0,40,20,.1)}
#toolbar .tb-label{color:rgba(0,62,35,.5);margin-right:2px;white-space:nowrap}
#toolbar button{padding:5px 12px;border-radius:6px;border:1px solid rgba(0,62,35,.15);background:rgba(0,62,35,.06);color:var(--dk);font-size:12px;cursor:pointer;transition:all .15s;white-space:nowrap;font-family:inherit}
#toolbar button:hover{background:rgba(80,187,78,.15)}
#toolbar button.active{background:var(--pk);color:#fff;border-color:var(--pk);font-weight:600}
#toolbar .tb-sep{width:1px;height:18px;background:rgba(0,62,35,.12);margin:0 4px}
#toolbar .save-indicator{font-size:11px;color:var(--pk);opacity:0;transition:opacity .3s;white-space:nowrap}
#toolbar .save-indicator.show{opacity:1}

/* â”€â”€ Edit mode body state â”€â”€ */
body.edit-mode #map-container{cursor:default}
body.edit-mode .island-group{cursor:move !important}
body.edit-mode .island-group:hover{filter:brightness(1.12)}
body.edit-mode .island-group.dragging{opacity:.85;filter:brightness(1.2) drop-shadow(0 0 12px rgba(80,187,78,.5))}

/* â”€â”€ Snap-back animation â”€â”€ */
@keyframes snapPulse{0%{filter:brightness(1.3) drop-shadow(0 0 10px var(--pk))}100%{filter:none}}
.snap-placed{animation:snapPulse .4s ease-out}
/* â”€â”€ Label hover effect â”€â”€ */
.island-label{transition:transform 0.2s ease}
.island-group:hover .island-label{transform:scale(1.08)}

/* â”€â”€ Table view (light green/white theme matching Dina brand) â”€â”€ */
#table-view{position:fixed;top:52px;left:0;right:0;bottom:0;background:var(--pg);z-index:790;display:none;overflow:auto;padding:20px 28px}
#table-view.active{display:block}
body.view-table #map-container,body.view-table #compass,body.view-table #minimap,body.view-table #legend,body.view-table #zoom-ctrl,body.view-table #ship{display:none}
#table-view .table-header{display:flex;align-items:center;justify-content:space-between;margin-bottom:16px}
#table-view .table-header h2{color:var(--dk);font-size:20px;font-weight:700}
#table-view .table-header h2 span{color:var(--pk)}
#table-view .table-header .table-count{color:#5a7a5a;font-size:13px}
#table-view table{width:100%;border-collapse:collapse;font-size:13px;background:#fff;border-radius:12px;overflow:hidden;box-shadow:0 2px 12px rgba(0,40,20,.08)}
#table-view thead th{position:sticky;top:0;background:var(--dk);color:#fff;font-weight:600;font-size:12px;text-transform:uppercase;letter-spacing:.5px;padding:11px 12px;text-align:left;border-bottom:2px solid var(--pk);cursor:pointer;user-select:none;white-space:nowrap;transition:background .15s}
#table-view thead th:hover{background:#00562f}
#table-view thead th .sort-arrow{display:inline-block;margin-left:4px;font-size:10px;opacity:.5;transition:opacity .15s}
#table-view thead th.sorted .sort-arrow{opacity:1;color:var(--pk)}
#table-view tbody tr{border-bottom:1px solid #e0ece0;transition:background .12s;cursor:pointer}
#table-view tbody tr:hover{background:rgba(80,187,78,.08)}
#table-view tbody tr:nth-child(even){background:#f5faf5}
#table-view tbody tr:nth-child(even):hover{background:rgba(80,187,78,.12)}
#table-view tbody td{padding:9px 12px;color:#1a3a1a;vertical-align:middle}
#table-view tbody td.name-cell{font-weight:600;white-space:nowrap;color:var(--dk)}
#table-view .type-badge{display:inline-block;padding:2px 8px;border-radius:10px;font-size:11px;font-weight:600;letter-spacing:.3px}
#table-view .type-badge.hub{background:rgba(212,168,67,.15);color:#8a6a20;border:1px solid rgba(212,168,67,.3)}
#table-view .type-badge.satellite{background:rgba(80,187,78,.12);color:#2a7a2a;border:1px solid rgba(80,187,78,.25)}
#table-view .type-badge.dept{background:rgba(60,130,160,.1);color:#2a6a80;border:1px solid rgba(60,130,160,.2)}
#table-view .type-badge.project{background:rgba(160,70,110,.1);color:#8a3a5a;border:1px solid rgba(160,70,110,.2)}
#table-view .terrain-dot{display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:6px;vertical-align:middle}
#table-view .activity-dot{display:inline-block;width:8px;height:8px;border-radius:50%;margin-right:6px;vertical-align:middle}
#table-view .libs-list{font-size:11px;color:#5a7a5a;max-width:280px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
#table-view .visited-badge{font-size:11px;padding:2px 7px;border-radius:8px}
#table-view .visited-badge.yes{background:rgba(80,187,78,.15);color:#2a7a2a}
#table-view .visited-badge.no{background:rgba(0,0,0,.04);color:#8a8a8a}

/* â”€â”€ Card view â”€â”€ */
#card-view{position:fixed;top:52px;left:0;right:0;bottom:0;background:var(--pg);z-index:790;display:none;overflow-y:auto;padding:0}
#card-view.active{display:block}
body.view-card #map-container,body.view-card #compass,body.view-card #minimap,body.view-card #legend,body.view-card #zoom-ctrl,body.view-card #ship{display:none}
#card-view .cv-header{display:flex;align-items:center;gap:16px;padding:16px 28px 0;flex-wrap:wrap}
#card-view .cv-header h2{color:var(--dk);font-size:20px;font-weight:700;white-space:nowrap}
#card-view .cv-header h2 span{color:var(--pk)}
#card-view .cv-search{flex:1;max-width:360px;position:relative}
#card-view .cv-search input{width:100%;padding:8px 14px 8px 36px;border-radius:8px;border:1px solid rgba(0,62,35,.15);background:#fff;color:var(--dk);font-size:14px;outline:none;transition:border-color .2s,box-shadow .2s;font-family:inherit}
#card-view .cv-search input:focus{border-color:var(--pk);box-shadow:0 0 0 3px rgba(80,187,78,.15)}
#card-view .cv-search input::placeholder{color:#8aaa8a}
#card-view .cv-search .search-icon{position:absolute;left:11px;top:50%;transform:translateY(-50%);color:#8aaa8a;font-size:14px;pointer-events:none}
#card-view .cv-count{color:#5a7a5a;font-size:13px;white-space:nowrap;margin-left:auto}

/* Buckets */
#bucket-area{padding:12px 28px 0;display:flex;flex-direction:column;gap:10px}
.bucket{background:#fff;border:2px dashed rgba(0,62,35,.15);border-radius:12px;width:100%;transition:border-color .2s,background .2s,box-shadow .2s}
.bucket.drag-over{border-color:var(--pk);background:rgba(80,187,78,.06);box-shadow:0 0 0 3px rgba(80,187,78,.12)}
.bucket .bucket-header{display:flex;align-items:center;gap:8px;padding:10px 16px;cursor:default;border-bottom:1px solid rgba(0,62,35,.06)}
.bucket .bucket-color{width:14px;height:14px;border-radius:4px;flex-shrink:0}
.bucket .bucket-name{font-size:14px;font-weight:600;color:var(--dk);flex:1;border:none;background:transparent;outline:none;font-family:inherit;cursor:text;padding:2px 4px;border-radius:4px}
.bucket .bucket-name:focus{background:rgba(80,187,78,.08);box-shadow:0 0 0 2px rgba(80,187,78,.2)}
.bucket .bucket-count{font-size:11px;color:#8aaa8a}
.bucket .bucket-del{width:22px;height:22px;border:none;background:transparent;color:#aaa;font-size:14px;cursor:pointer;border-radius:50%;display:flex;align-items:center;justify-content:center;transition:all .15s}
.bucket .bucket-del:hover{background:rgba(200,50,50,.08);color:#c44}
.bucket .bucket-cards{padding:12px 16px;display:grid;grid-template-columns:repeat(auto-fill,minmax(280px,1fr));gap:16px;min-height:40px}
.bucket .bucket-empty{grid-column:1/-1;text-align:center;color:#bbb;font-size:12px;padding:8px 0}
#addBucketBtn{padding:8px 16px;border:2px dashed rgba(0,62,35,.12);border-radius:12px;background:transparent;color:var(--pk);font-size:13px;font-weight:600;cursor:pointer;transition:all .15s;white-space:nowrap;font-family:inherit;min-height:44px;display:flex;align-items:center;justify-content:center;width:fit-content}
#addBucketBtn:hover{border-color:var(--pk);background:rgba(80,187,78,.04)}

/* Card grid */
#card-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(280px,1fr));gap:16px;padding:16px 28px 28px}
#card-grid.has-search-results{grid-template-columns:repeat(auto-fill,minmax(280px,1fr))}
.site-card{background:#fff;border-radius:12px;overflow:hidden;cursor:pointer;transition:transform .15s,box-shadow .15s;border:1px solid rgba(0,62,35,.08);position:relative;display:flex;flex-direction:column}
.site-card:hover{transform:translateY(-2px);box-shadow:0 6px 20px rgba(0,40,20,.1)}
.site-card.dragging{opacity:.4;transform:scale(.96)}
.site-card .card-stripe{height:6px;flex-shrink:0}
.site-card .card-stripe.hub{background:linear-gradient(90deg,var(--gold),#e8c060)}
.site-card .card-stripe.satellite{background:linear-gradient(90deg,var(--pk),#70d870)}
.site-card .card-stripe.dept{background:linear-gradient(90deg,#4a9ab8,#6abcd8)}
.site-card .card-stripe.project{background:linear-gradient(90deg,#a84a88,#c870a8)}
.site-card .card-body{padding:14px 16px 12px;flex:1;display:flex;flex-direction:column}
.site-card .card-top{display:flex;align-items:flex-start;gap:12px;margin-bottom:10px}
.site-card .card-initials{width:42px;height:42px;border-radius:10px;display:flex;align-items:center;justify-content:center;font-size:16px;font-weight:700;color:#fff;flex-shrink:0;letter-spacing:.5px}
.site-card .card-initials.hub{background:linear-gradient(135deg,#b8922a,var(--gold))}
.site-card .card-initials.satellite{background:linear-gradient(135deg,#38a838,var(--pk))}
.site-card .card-initials.dept{background:linear-gradient(135deg,#3a8aa8,#4a9ab8)}
.site-card .card-initials.project{background:linear-gradient(135deg,#8a3a68,#a84a88)}
.site-card .card-info{flex:1;min-width:0}
.site-card .card-name{font-size:14px;font-weight:700;color:var(--dk);line-height:1.3;margin-bottom:2px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.site-card .card-template{font-size:11px;color:#5a7a5a}
.site-card .card-star{position:absolute;top:12px;right:12px;width:28px;height:28px;border:none;background:transparent;cursor:pointer;font-size:16px;color:#ccc;transition:color .15s;display:flex;align-items:center;justify-content:center;border-radius:50%}
.site-card .card-star:hover{color:var(--gold)}
.site-card .card-star.starred{color:var(--gold)}
.site-card .card-stats{display:flex;gap:14px;padding:8px 0;border-top:1px solid rgba(0,62,35,.06)}
.site-card .card-stat{display:flex;align-items:center;gap:4px;font-size:12px;color:#3a6a3a;position:relative}
.site-card .card-stat .stat-icon{font-size:13px;color:#8aaa8a}
.site-card .card-stat .stat-val{font-weight:700;font-variant-numeric:tabular-nums}
.site-card .card-stat.has-tooltip{cursor:default}
.site-card .card-stat .lib-tooltip{display:none;position:absolute;bottom:calc(100% + 6px);left:50%;transform:translateX(-50%);background:#fff;border:1px solid rgba(0,62,35,.12);border-radius:8px;padding:8px 12px;min-width:180px;max-width:260px;box-shadow:0 4px 16px rgba(0,40,20,.12);z-index:20;font-size:11px;color:#3a5a3a;white-space:normal}
.site-card .card-stat.has-tooltip:hover .lib-tooltip{display:block}
.site-card .card-stat .lib-tooltip .lt-item{display:flex;align-items:center;gap:5px;padding:2px 0}
.site-card .card-stat .lib-tooltip .lt-dot{width:5px;height:5px;border-radius:50%;background:var(--pk);flex-shrink:0;opacity:.5}
.site-card .card-stat .lib-tooltip .lt-count{margin-left:auto;color:#8aaa8a;font-size:10px;flex-shrink:0}
.site-card .card-stat .lib-tooltip::after{content:'';position:absolute;top:100%;left:50%;transform:translateX(-50%);border:5px solid transparent;border-top-color:rgba(0,62,35,.12)}
.site-card .card-color-bar{height:6px;flex-shrink:0;display:none}
.site-card.has-custom-color .card-color-bar{display:block}
.site-card.has-custom-color .card-stripe{display:none}
.site-card .card-activity{position:absolute;bottom:14px;right:14px;width:10px;height:10px;border-radius:50%;border:2px solid #fff;box-shadow:0 0 0 1px rgba(0,0,0,.08)}
.site-card .card-type-badge{display:inline-block;font-size:10px;font-weight:600;padding:1px 6px;border-radius:4px;margin-top:1px}
.site-card .card-type-badge.hub{background:rgba(212,168,67,.12);color:#8a6a20}
.site-card .card-type-badge.satellite{background:rgba(80,187,78,.1);color:#2a7a2a}
.site-card .card-type-badge.dept{background:rgba(60,130,160,.08);color:#2a6a80}
.site-card .card-type-badge.project{background:rgba(160,70,110,.08);color:#8a3a5a}
.card-no-results{grid-column:1/-1;text-align:center;padding:40px 20px;color:#8aaa8a;font-size:15px}

/* Right-click color context menu */
#card-ctx-menu{position:fixed;z-index:9999;background:#fff;border:1px solid rgba(0,62,35,.12);border-radius:10px;padding:8px;box-shadow:0 6px 24px rgba(0,40,20,.15);display:none;min-width:160px}
#card-ctx-menu.open{display:block}
#card-ctx-menu .ctx-label{font-size:11px;color:#8aaa8a;padding:2px 8px 6px;font-weight:600;letter-spacing:.3px}
#card-ctx-menu .ctx-colors{display:flex;flex-wrap:wrap;gap:6px;padding:4px 6px}
#card-ctx-menu .ctx-swatch{width:24px;height:24px;border-radius:6px;cursor:pointer;border:2px solid transparent;transition:transform .1s,border-color .1s}
#card-ctx-menu .ctx-swatch:hover{transform:scale(1.15);border-color:var(--dk)}
#card-ctx-menu .ctx-swatch.active{border-color:var(--dk);box-shadow:0 0 0 2px rgba(0,62,35,.15)}
#card-ctx-menu .ctx-clear{width:100%;margin-top:4px;padding:5px 8px;border:none;background:rgba(0,0,0,.03);border-radius:6px;font-size:11px;color:#5a7a5a;cursor:pointer;font-family:inherit;transition:background .12s}
#card-ctx-menu .ctx-clear:hover{background:rgba(0,0,0,.06)}
</style>
</head>
<body>

<!-- Topbar -->
<header id="topbar">
  <div class="logo">&#9875; Dina <span>Sk&auml;rg&aring;rd</span></div>
  <div class="era-banner">&#9203; Digitaliseringseran &ndash; 2024</div>
  <div class="search-wrap">
    <span class="search-icon">&#128269;</span>
    <input type="text" id="searchInput" placeholder="S&ouml;k webbplats, dokument, person&hellip;">
  </div>
  <div class="user-avatar" title="Anna Lindberg">AL</div>
</header>

<!-- Map container -->
<div id="map-container">
  <svg id="map-svg" xmlns="http://www.w3.org/2000/svg"></svg>
</div>

<!-- Ship marker -->
<div id="ship">
  <svg viewBox="0 0 40 40" fill="none">
    <path d="M20 2 L28 22 Q24 28 20 30 Q16 28 12 22 Z" fill="var(--gold)" stroke="#8a6a20" stroke-width="1"/>
    <path d="M20 2 L20 30 L12 22 Z" fill="rgba(255,255,255,.25)"/>
    <line x1="20" y1="2" x2="20" y2="36" stroke="#6a4a20" stroke-width="2" stroke-linecap="round"/>
    <ellipse cx="20" cy="36" rx="8" ry="3" fill="#5a3a15" opacity=".8"/>
  </svg>
</div>

<!-- Compass -->
<div id="compass">
  <svg viewBox="0 0 80 80">
    <circle cx="40" cy="40" r="36" fill="rgba(0,30,15,.7)" stroke="rgba(212,168,67,.5)" stroke-width="1.5"/>
    <circle cx="40" cy="40" r="28" fill="none" stroke="rgba(212,168,67,.2)" stroke-width=".5"/>
    <polygon points="40,8 44,36 40,32 36,36" fill="var(--gold)" opacity=".9"/>
    <polygon points="40,72 44,44 40,48 36,44" fill="rgba(255,255,255,.3)"/>
    <polygon points="8,40 36,36 32,40 36,44" fill="rgba(255,255,255,.3)"/>
    <polygon points="72,40 44,36 48,40 44,44" fill="rgba(255,255,255,.3)"/>
    <text x="40" y="7" text-anchor="middle" font-size="8" fill="var(--gold)" font-weight="700">N</text>
    <text x="40" y="79" text-anchor="middle" font-size="7" fill="rgba(255,255,255,.4)">S</text>
    <text x="4" y="43" text-anchor="middle" font-size="7" fill="rgba(255,255,255,.4)">V</text>
    <text x="76" y="43" text-anchor="middle" font-size="7" fill="rgba(255,255,255,.4)">&Ouml;</text>
  </svg>
</div>

<!-- Minimap -->
<div id="minimap">
  <canvas id="minimap-canvas" width="400" height="300"></canvas>
  <div class="viewport-rect" id="minimap-vp"></div>
</div>

<!-- Legend -->
<div id="legend">
  <h4>&#128506; Teckenf&ouml;rklaring</h4>
  <div class="leg-item"><div class="leg-dot" style="background:var(--gold);border:2px solid #b8942a"></div> Hub-webbplats</div>
  <div class="leg-item"><div class="leg-dot" style="background:var(--pk)"></div> Satellit-webbplats</div>
  <div class="leg-item"><div class="leg-dot" style="background:#5a9aaa"></div> Frist&aring;ende webbplats</div>
  <div class="leg-item"><div class="leg-dot" style="background:#aa5a7a"></div> Projektwebbplats</div>
  <div class="leg-item"><div class="leg-line"></div> Brygga (hub-koppling)</div>
  <div class="leg-item"><div class="leg-dot" style="background:rgba(100,100,100,.3);border:1px dashed rgba(0,62,35,.3)"></div> Ej bes&ouml;kt (dimma)</div>
  <hr style="border:0;border-top:1px solid rgba(255,255,255,.1);margin:8px 0">
  <div class="leg-item"><div class="leg-dot" style="background:rgba(200,160,60,.3);border:2px solid rgba(212,168,67,.5)"></div> Kommunikationswebbplats</div>
  <div class="leg-item"><div class="leg-dot" style="background:rgba(80,140,200,.2);border:2px dashed rgba(100,160,210,.5)"></div> Gruppwebbplats (Team)</div>
</div>

<!-- Zoom controls -->
<div id="zoom-ctrl">
  <button id="zoomIn" title="Zooma in (+)">+</button>
  <button id="zoomOut" title="Zooma ut (&minus;)">&minus;</button>
  <button id="zoomReset" title="&Aring;terst&auml;ll vy (0)">&#8962;</button>
</div>

<!-- Toolbar -->
<div id="toolbar">
  <span class="tb-label">LÃ¤ge:</span>
  <button id="btnNavigate" class="active" title="Navigera och utforska Ã¶arna">ðŸ§­ Navigera</button>
  <button id="btnArrange" title="Flytta Ã¶ar och anpassa din karta">âœ‹ Arrangera</button>
  <div class="tb-sep"></div>
  <button id="btnResetLayout" title="Ã…terstÃ¤ll alla Ã¶ar till originalposition">â†© Ã…terstÃ¤ll</button>
  <span class="save-indicator" id="saveIndicator">âœ“ Sparad</span>
  <div class="tb-sep"></div>
  <span class="tb-label">Vy:</span>
  <button id="btnCardView" class="active" title="Kortvy">Kort</button>
  <button id="btnMapView" title="Kartvy">Karta</button>
  <button id="btnTableView" title="Tabellvy">Tabell</button>
</div>

<!-- Card view -->
<div id="card-view">
  <div class="cv-header">
    <h2>Alla <span>webbplatser</span></h2>
    <div class="cv-search">
      <span class="search-icon">&#128269;</span>
      <input type="text" id="cardSearch" placeholder="S&ouml;k webbplatser...">
    </div>
    <span class="cv-count" id="card-count"></span>
  </div>
  <div id="bucket-area">
    <div id="bucket-list"></div>
    <button id="addBucketBtn" title="L&auml;gg till kategori">+ Ny kategori</button>
  </div>
  <div id="card-grid"></div>
</div>

<!-- Card context menu -->
<div id="card-ctx-menu">
  <div class="ctx-label">F&auml;rgmarkera</div>
  <div class="ctx-colors" id="ctx-colors"></div>
  <button class="ctx-clear" id="ctx-clear">Ta bort f&auml;rg</button>
</div>

<!-- Detail panel -->
<div id="detail-panel">
  <button class="dp-close" id="dp-close">&#10005;</button>
  <div class="dp-header">
    <div class="dp-emoji" id="dp-emoji"></div>
    <div class="dp-name" id="dp-name"></div>
    <div class="dp-type" id="dp-type"></div>
    <div class="dp-terrain" id="dp-terrain"></div>
  </div>
  <div class="dp-desc" id="dp-desc"></div>
  <div class="dp-stats">
    <div class="dp-stat"><div class="val" id="dp-docs">0</div><div class="lbl">Dokument</div></div>
    <div class="dp-stat"><div class="val" id="dp-libcount">0</div><div class="lbl">Bibliotek</div></div>
    <div class="dp-stat"><div class="val" id="dp-activity">&ndash;</div><div class="lbl">Aktivitet</div></div>
  </div>
  <div class="dp-libs" id="dp-libs"><h4>&#128218; Dokumentbibliotek</h4><div id="dp-lib-list"></div></div>
  <div class="dp-actions">
    <button class="btn-primary" onclick="showToast('&Ouml;ppnar i SharePoint&hellip;')">&#128194; &Ouml;ppna i SharePoint</button>
    <button class="btn-secondary" onclick="showToast('&Ouml;ppnar i Teams&hellip;')">&#128172; &Ouml;ppna i Teams</button>
    <button class="btn-secondary" onclick="showToast('L&auml;nk kopierad!')">&#128279; Kopiera l&auml;nk</button>
  </div>
</div>

<!-- Table view -->
<div id="table-view">
  <div class="table-header">
    <h2>&#128506; Alla <span>webbplatser</span></h2>
    <span class="table-count" id="table-count"></span>
  </div>
  <table id="sites-table">
    <thead><tr id="table-head"></tr></thead>
    <tbody id="table-body"></tbody>
  </table>
</div>

<!-- Toast -->
<div id="toast"></div>

<script>
// ========== DATA ==========
const TERRAIN = {
  forest:   {base:'#2d7a4f', light:'#48b870', deep:'#1a4e30', beach:'#d4b06a', water:'#1a8090'},
  meadow:   {base:'#5a9a3a', light:'#7ec45a', deep:'#3a6a24', beach:'#d8c480', water:'#2090a0'},
  snow:     {base:'#7898b8', light:'#a8c8e8', deep:'#4a6888', beach:'#b0b8c0', water:'#4090b0'},
  desert:   {base:'#c4a048', light:'#e0c870', deep:'#8a6e28', beach:'#e8d8a0', water:'#3098a0'},
  volcanic: {base:'#5a4848', light:'#786060', deep:'#3a2828', beach:'#786058', water:'#2a6878'},
  tropical: {base:'#2aaa5a', light:'#50d880', deep:'#188840', beach:'#f0d878', water:'#18a0a8'},
  rocky:    {base:'#6a7a8a', light:'#8a9aaa', deep:'#4a5a6a', beach:'#a0a898', water:'#3080a0'},
  marsh:    {base:'#4a6a3a', light:'#6a8a5a', deep:'#2a4a20', beach:'#7a8868', water:'#2a7868'}
};
const TERRAIN_NAMES = {forest:'Skogsmark',meadow:'\u00c4ngsmark',snow:'Sn\u00f6landskap',desert:'\u00d6kenmark',volcanic:'Vulkaniskt',tropical:'Tropiskt',rocky:'Klippmark',marsh:'Myrmark'};

// SharePoint site template classification
// Communication Sites: hubs, broadcasting/publishing portals, intranets
// Team Sites: collaborative workspaces, departments, projects
const COMM_SITES = new Set([
  'koncern','dinab','lantbruk','liv','gemit','ekofin', // all hubs
  'komm','intranat','utbild','intro','forskning'       // publishing/broadcast sites
]);
function siteTemplate(isl) { return COMM_SITES.has(isl.id) ? 'comm' : 'team'; }
const SITE_LABELS = {comm:'Kommunikationswebbplats', team:'Gruppwebbplats'};

const islands = [
  // === HUBS (6) ===
  {id:'koncern',name:'Koncernledning',emoji:'\u{1F3DB}\uFE0F',type:'hub',group:'dina',hubId:null,x:0,y:0,rx:140,ry:88,terrain:'meadow',docs:156,
   libs:[{n:'Styrelsehandlingar',i:'\u{1F4CB}',c:42},{n:'\u00c5rsredovisningar',i:'\u{1F4CA}',c:28},{n:'Strategidokument',i:'\u{1F3AF}',c:86}],
   visited:true,activity:'high',desc:'Koncernens centrala knutpunkt. Styrelsebeslut, strategier och \u00e5rsredovisningar.'},
  {id:'dinab',name:'Dina F\u00f6rs\u00e4kringar AB',emoji:'\u{1F3E2}',type:'hub',group:'dina',hubId:null,x:-650,y:-450,rx:120,ry:75,terrain:'forest',docs:234,
   libs:[{n:'Policyer',i:'\u{1F4CB}',c:58},{n:'Rutiner',i:'\u{1F4CC}',c:72},{n:'Rapporter',i:'\u{1F4CA}',c:104}],
   visited:true,activity:'high',desc:'Huvudbolaget med k\u00e4rnverksamhetens dokumentation.'},
  {id:'lantbruk',name:'Dina Lantbruk',emoji:'\u{1F69C}',type:'hub',group:'lantbruk',hubId:null,x:700,y:-400,rx:110,ry:68,terrain:'meadow',docs:189,
   libs:[{n:'Skadehantering',i:'\u{1F6E1}\uFE0F',c:67},{n:'Riskmodeller',i:'\u{1F4CA}',c:55},{n:'Premiedok',i:'\u{1F4B9}',c:67}],
   visited:true,activity:'high',desc:'Lantbruksf\u00f6rs\u00e4kringar \u2013 specialiserade produkter f\u00f6r jord och skog.'},
  {id:'liv',name:'Dina Liv',emoji:'\u{1F49A}',type:'hub',group:'liv',hubId:null,x:750,y:500,rx:100,ry:62,terrain:'tropical',docs:142,
   libs:[{n:'Livprodukter',i:'\u{1F49A}',c:48},{n:'Villkor',i:'\u{1F4DC}',c:52},{n:'Aktuariedok',i:'\u{1F4D0}',c:42}],
   visited:true,activity:'medium',desc:'Livf\u00f6rs\u00e4kringsbolaget med produkter och villkor.'},
  {id:'gemit',name:'Gemensam IT',emoji:'\u{1F4BB}',type:'hub',group:'shared',hubId:null,x:-700,y:500,rx:110,ry:68,terrain:'rocky',docs:198,
   libs:[{n:'Arkitektur',i:'\u{1F3D7}\uFE0F',c:56},{n:'S\u00e4kerhet',i:'\u{1F512}',c:48},{n:'Projekt',i:'\u{1F4C1}',c:94}],
   visited:true,activity:'high',desc:'IT-organisationens gemensamma portal f\u00f6r teknik och system.'},
  {id:'ekofin',name:'Ekonomi & Finans',emoji:'\u{1F4B0}',type:'hub',group:'dina',hubId:null,x:50,y:600,rx:105,ry:65,terrain:'snow',docs:167,
   libs:[{n:'Budget',i:'\u{1F4B9}',c:35},{n:'Kvartalsrapporter',i:'\u{1F4CA}',c:62},{n:'Revision',i:'\u{1F50D}',c:70}],
   visited:true,activity:'medium',desc:'Ekonomistyrning, budgetarbete och finansiell rapportering.'},

  // === Satellites of Koncernledning (4) ===
  {id:'styrelse',name:'Styrelseportalen',emoji:'\u{1F4CB}',type:'satellite',group:'dina',hubId:'koncern',x:-230,y:-200,rx:60,ry:38,terrain:'meadow',docs:42,
   libs:[{n:'Protokoll',i:'\u{1F4CB}',c:22},{n:'Underlag',i:'\u{1F4C4}',c:20}],visited:true,activity:'medium',desc:'Styrelseprotokoll och beslutsunderlag.'},
  {id:'strategi',name:'Strategi & Utveckling',emoji:'\u{1F3AF}',type:'satellite',group:'dina',hubId:'koncern',x:260,y:-190,rx:70,ry:42,terrain:'forest',docs:86,
   libs:[{n:'Strategiplaner',i:'\u{1F3AF}',c:34},{n:'Aff\u00e4rsplaner',i:'\u{1F4CA}',c:28},{n:'Omv\u00e4rld',i:'\u{1F30D}',c:24}],visited:true,activity:'high',desc:'Strategisk planering och aff\u00e4rsutveckling.'},
  {id:'internrev',name:'Internrevision',emoji:'\u{1F50D}',type:'satellite',group:'dina',hubId:'koncern',x:-210,y:180,rx:55,ry:35,terrain:'rocky',docs:38,
   libs:[{n:'Revisionsrapporter',i:'\u{1F50D}',c:22},{n:'Uppf\u00f6ljning',i:'\u{1F4CB}',c:16}],visited:true,activity:'low',desc:'Internrevisionsrapporter och uppf\u00f6ljning.'},
  {id:'komm',name:'Kommunikation',emoji:'\u{1F4E3}',type:'satellite',group:'dina',hubId:'koncern',x:240,y:200,rx:58,ry:36,terrain:'tropical',docs:55,
   libs:[{n:'Mallar',i:'\u{1F4DD}',c:25},{n:'Varum\u00e4rke',i:'\u{1F3A8}',c:18},{n:'Press',i:'\u{1F4F0}',c:12}],visited:true,activity:'medium',desc:'Intern och extern kommunikation, varum\u00e4rkesguider.'},

  // === Satellites of Dina FÃ¶rsÃ¤kringar AB (5) ===
  {id:'skade',name:'Skadereglering',emoji:'\u{1F6E1}\uFE0F',type:'satellite',group:'dina',hubId:'dinab',x:-900,y:-600,rx:90,ry:55,terrain:'forest',docs:312,
   libs:[{n:'Handl\u00e4ggning',i:'\u{1F4CB}',c:120},{n:'Statistik',i:'\u{1F4CA}',c:92},{n:'Rutiner',i:'\u{1F4CC}',c:100}],visited:true,activity:'high',desc:'Handl\u00e4ggning av skade\u00e4renden f\u00f6r alla produktlinjer.'},
  {id:'uw',name:'Underwriting',emoji:'\u{1F4CA}',type:'satellite',group:'dina',hubId:'dinab',x:-430,y:-630,rx:75,ry:46,terrain:'snow',docs:178,
   libs:[{n:'Riskbed\u00f6mning',i:'\u{1F50D}',c:68},{n:'Premiemodeller',i:'\u{1F4B9}',c:62},{n:'Acceptregler',i:'\u2705',c:48}],visited:true,activity:'high',desc:'Riskbed\u00f6mning, premies\u00e4ttning och produktgodk\u00e4nnande.'},
  {id:'ks',name:'Kundservice',emoji:'\u{1F3A7}',type:'satellite',group:'dina',hubId:'dinab',x:-850,y:-280,rx:60,ry:38,terrain:'meadow',docs:94,
   libs:[{n:'Manus',i:'\u{1F4DD}',c:42},{n:'FAQ',i:'\u2753',c:32},{n:'Utbildning',i:'\u{1F393}',c:20}],visited:true,activity:'medium',desc:'Kundkontakt, supportmanus och \u00e4rendehantering.'},
  {id:'forsalj',name:'F\u00f6rs\u00e4ljning',emoji:'\u{1F4BC}',type:'satellite',group:'dina',hubId:'dinab',x:-440,y:-280,rx:65,ry:40,terrain:'tropical',docs:128,
   libs:[{n:'Presentationer',i:'\u{1F4CA}',c:48},{n:'Kampanjer',i:'\u{1F4E3}',c:40},{n:'Avtal',i:'\u{1F91D}',c:40}],visited:false,activity:'medium',desc:'S\u00e4ljmaterial, kampanjer och partneravtal.'},
  {id:'jurcomp',name:'Juridik & Compliance',emoji:'\u2696\uFE0F',type:'satellite',group:'dina',hubId:'dinab',x:-670,y:-680,rx:78,ry:48,terrain:'rocky',docs:201,
   libs:[{n:'Villkor',i:'\u{1F4DC}',c:82},{n:'Avtal',i:'\u{1F91D}',c:62},{n:'GDPR',i:'\u{1F512}',c:57}],visited:true,activity:'medium',desc:'F\u00f6rs\u00e4kringsvillkor, avtalsjuridik och regulatorisk efterlevnad.'},

  // === Satellites of Dina Lantbruk (4) ===
  {id:'ltskade',name:'Lantbruk Skador',emoji:'\u{1F6E1}\uFE0F',type:'satellite',group:'lantbruk',hubId:'lantbruk',x:500,y:-570,rx:72,ry:44,terrain:'meadow',docs:145,
   libs:[{n:'Besiktningar',i:'\u{1F50D}',c:58},{n:'Handl\u00e4ggning',i:'\u{1F4CB}',c:52},{n:'Statistik',i:'\u{1F4CA}',c:35}],visited:true,activity:'high',desc:'Skadehantering f\u00f6r lantbruksf\u00f6rs\u00e4kringar.'},
  {id:'ltuw',name:'Lantbruk Underwriting',emoji:'\u{1F4CA}',type:'satellite',group:'lantbruk',hubId:'lantbruk',x:920,y:-540,rx:65,ry:40,terrain:'forest',docs:98,
   libs:[{n:'Riskmodeller',i:'\u{1F4CA}',c:48},{n:'Tariffer',i:'\u{1F4B9}',c:50}],visited:true,activity:'medium',desc:'Riskbed\u00f6mning och tariffering f\u00f6r lantbruk.'},
  {id:'ltks',name:'Lantbruk Kundkontakt',emoji:'\u{1F4DE}',type:'satellite',group:'lantbruk',hubId:'lantbruk',x:520,y:-270,rx:55,ry:35,terrain:'marsh',docs:52,
   libs:[{n:'Kundmanus',i:'\u{1F4DD}',c:28},{n:'FAQ',i:'\u2753',c:24}],visited:false,activity:'low',desc:'Kundkontakt och r\u00e5dgivning f\u00f6r lantbrukskunder.'},
  {id:'ltfalt',name:'F\u00e4lt & Besiktning',emoji:'\u{1F33E}',type:'satellite',group:'lantbruk',hubId:'lantbruk',x:900,y:-260,rx:60,ry:38,terrain:'meadow',docs:76,
   libs:[{n:'Protokoll',i:'\u{1F4CB}',c:38},{n:'Checklistor',i:'\u2705',c:38}],visited:true,activity:'medium',desc:'F\u00e4ltbesiktning och riskbed\u00f6mning p\u00e5 plats.'},

  // === Satellites of Dina Liv (4) ===
  {id:'livprod',name:'Livprodukter',emoji:'\u{1F4E6}',type:'satellite',group:'liv',hubId:'liv',x:570,y:370,rx:62,ry:38,terrain:'tropical',docs:87,
   libs:[{n:'Produktblad',i:'\u{1F4C4}',c:42},{n:'Villkor',i:'\u{1F4DC}',c:45}],visited:true,activity:'medium',desc:'Livf\u00f6rs\u00e4kringsprodukter och villkorsdokumentation.'},
  {id:'livskade',name:'Liv Skadehantering',emoji:'\u{1F6E1}\uFE0F',type:'satellite',group:'liv',hubId:'liv',x:940,y:380,rx:58,ry:36,terrain:'forest',docs:65,
   libs:[{n:'Handl\u00e4ggning',i:'\u{1F4CB}',c:35},{n:'Statistik',i:'\u{1F4CA}',c:30}],visited:false,activity:'low',desc:'Skadehantering f\u00f6r livf\u00f6rs\u00e4kringar.'},
  {id:'livakt',name:'Liv Aktuarier',emoji:'\u{1F4D0}',type:'satellite',group:'liv',hubId:'liv',x:580,y:640,rx:68,ry:42,terrain:'snow',docs:112,
   libs:[{n:'Modeller',i:'\u{1F4D0}',c:52},{n:'Rapporter',i:'\u{1F4CA}',c:38},{n:'Antaganden',i:'\u{1F4CB}',c:22}],visited:true,activity:'medium',desc:'Aktuariella ber\u00e4kningar och antaganden f\u00f6r livf\u00f6rs\u00e4kring.'},
  {id:'livforsa',name:'Liv F\u00f6rs\u00e4ljning',emoji:'\u{1F4BC}',type:'satellite',group:'liv',hubId:'liv',x:920,y:630,rx:55,ry:34,terrain:'meadow',docs:48,
   libs:[{n:'Material',i:'\u{1F4CA}',c:28},{n:'Utbildning',i:'\u{1F393}',c:20}],visited:false,activity:'low',desc:'S\u00e4ljmaterial och utbildning f\u00f6r livf\u00f6rs\u00e4kring.'},

  // === Satellites of Gemensam IT (5) ===
  {id:'drift',name:'Drift & Infrastruktur',emoji:'\u{1F527}',type:'satellite',group:'shared',hubId:'gemit',x:-920,y:360,rx:70,ry:43,terrain:'rocky',docs:134,
   libs:[{n:'Driftdok',i:'\u{1F527}',c:56},{n:'N\u00e4tverkskartor',i:'\u{1F5FA}\uFE0F',c:38},{n:'Incident',i:'\u26A0\uFE0F',c:40}],visited:true,activity:'high',desc:'IT-infrastruktur, driftdokumentation och incidenthantering.'},
  {id:'utveckl',name:'Systemutveckling',emoji:'\u{1F5A5}\uFE0F',type:'satellite',group:'shared',hubId:'gemit',x:-500,y:360,rx:80,ry:48,terrain:'forest',docs:223,
   libs:[{n:'Specifikationer',i:'\u{1F4CB}',c:82},{n:'API-dok',i:'\u{1F50C}',c:68},{n:'Testplaner',i:'\u{1F9EA}',c:73}],visited:true,activity:'high',desc:'Systemutveckling, API-dokumentation och testning.'},
  {id:'itsakr',name:'IT-S\u00e4kerhet',emoji:'\u{1F512}',type:'satellite',group:'shared',hubId:'gemit',x:-900,y:620,rx:62,ry:38,terrain:'volcanic',docs:87,
   libs:[{n:'Policyer',i:'\u{1F4CB}',c:35},{n:'Incidenter',i:'\u26A0\uFE0F',c:28},{n:'Penetrationstester',i:'\u{1F50D}',c:24}],visited:true,activity:'medium',desc:'IT-s\u00e4kerhetspolicyer, incidenthantering och penetrationstester.'},
  {id:'digit',name:'Digitalisering',emoji:'\u{1F680}',type:'satellite',group:'shared',hubId:'gemit',x:-520,y:640,rx:72,ry:44,terrain:'tropical',docs:156,
   libs:[{n:'Roadmap',i:'\u{1F5FA}\uFE0F',c:42},{n:'Prototyper',i:'\u{1F3A8}',c:54},{n:'Analyser',i:'\u{1F4CA}',c:60}],visited:true,activity:'high',desc:'Digital transformation, roadmap och prototyper.'},
  {id:'support',name:'IT-Support',emoji:'\u{1F3AB}',type:'satellite',group:'shared',hubId:'gemit',x:-700,y:720,rx:50,ry:32,terrain:'meadow',docs:45,
   libs:[{n:'Guider',i:'\u{1F4DD}',c:25},{n:'FAQ',i:'\u2753',c:20}],visited:false,activity:'low',desc:'IT-supportguider och vanliga fr\u00e5gor.'},

  // === Satellites of Ekonomi & Finans (4) ===
  {id:'redovisn',name:'Redovisning',emoji:'\u{1F4D2}',type:'satellite',group:'dina',hubId:'ekofin',x:-140,y:460,rx:62,ry:38,terrain:'snow',docs:98,
   libs:[{n:'Bokslut',i:'\u{1F4CA}',c:42},{n:'Kontoplan',i:'\u{1F4D2}',c:28},{n:'Rutiner',i:'\u{1F4CC}',c:28}],visited:true,activity:'medium',desc:'Bokslut, kontoplan och redovisningsrutiner.'},
  {id:'controll',name:'Controlling',emoji:'\u{1F4C8}',type:'satellite',group:'dina',hubId:'ekofin',x:250,y:460,rx:58,ry:36,terrain:'meadow',docs:76,
   libs:[{n:'KPI-rapporter',i:'\u{1F4C8}',c:38},{n:'Analyser',i:'\u{1F4CA}',c:38}],visited:true,activity:'medium',desc:'Controlling, KPI-rapporter och verksamhetsanalyser.'},
  {id:'kapital',name:'KapitalfÃ¶rvaltning',emoji:'\u{1F3E6}',type:'satellite',group:'dina',hubId:'ekofin',x:-120,y:760,rx:68,ry:42,terrain:'rocky',docs:123,
   libs:[{n:'Placeringspolicy',i:'\u{1F4CB}',c:32},{n:'Rapporter',i:'\u{1F4CA}',c:52},{n:'Mandat',i:'\u{1F4DC}',c:39}],visited:true,activity:'medium',desc:'KapitalfÃ¶rvaltning, placeringspolicyer och rapporter.'},
  {id:'budget',name:'Budget & Prognos',emoji:'\u{1F5D3}\uFE0F',type:'satellite',group:'dina',hubId:'ekofin',x:230,y:760,rx:55,ry:34,terrain:'forest',docs:54,
   libs:[{n:'Budgetmallar',i:'\u{1F4CA}',c:28},{n:'Prognoser',i:'\u{1F4C8}',c:26}],visited:false,activity:'low',desc:'Budgetmallar och prognoser.'},

  // === STANDALONE (20) ===
  {id:'hr',name:'HR & Personal',emoji:'\u{1F465}',type:'dept',group:'standalone',hubId:null,x:-280,y:-480,rx:65,ry:40,terrain:'meadow',docs:128,
   libs:[{n:'Policyer',i:'\u{1F4CB}',c:42},{n:'Mallar',i:'\u{1F4DD}',c:38},{n:'Rekrytering',i:'\u{1F465}',c:48}],visited:true,activity:'medium',desc:'Personalhantering, rekrytering och kompetensutveckling.'},
  {id:'gdpr',name:'Dataskydd & GDPR',emoji:'\u{1F510}',type:'dept',group:'standalone',hubId:null,x:100,y:-400,rx:52,ry:33,terrain:'rocky',docs:67,
   libs:[{n:'Register',i:'\u{1F4CB}',c:32},{n:'Rutiner',i:'\u{1F4CC}',c:35}],visited:true,activity:'low',desc:'Dataskyddsregister och GDPR-rutiner.'},
  {id:'facility',name:'Facility Management',emoji:'\u{1F3D7}\uFE0F',type:'dept',group:'standalone',hubId:null,x:-350,y:300,rx:48,ry:30,terrain:'desert',docs:34,
   libs:[{n:'Ritningar',i:'\u{1F3D7}\uFE0F',c:18},{n:'Avtal',i:'\u{1F91D}',c:16}],visited:false,activity:'low',desc:'FastighetsfÃ¶rvaltning, ritningar och avtal.'},
  {id:'projcrm',name:'Projekt: Nytt CRM',emoji:'\u{1F680}',type:'project',group:'standalone',hubId:null,x:1100,y:-100,rx:58,ry:36,terrain:'volcanic',docs:89,
   libs:[{n:'Kravspec',i:'\u{1F4CB}',c:42},{n:'Testplaner',i:'\u{1F9EA}',c:47}],visited:true,activity:'high',desc:'PÃ¥gÃ¥ende projekt fÃ¶r nytt CRM-system.'},
  {id:'projwebb',name:'Projekt: Ny Webb',emoji:'\u{1F310}',type:'project',group:'standalone',hubId:null,x:1050,y:100,rx:52,ry:33,terrain:'tropical',docs:56,
   libs:[{n:'Design',i:'\u{1F3A8}',c:28},{n:'Content',i:'\u{1F4DD}',c:28}],visited:true,activity:'high',desc:'Nytt webbprojekt med design och inneh\u00e5ll.'},
  {id:'projm365',name:'Projekt: M365 Migration',emoji:'\u2601\uFE0F',type:'project',group:'standalone',hubId:null,x:-1050,y:-100,rx:60,ry:37,terrain:'snow',docs:112,
   libs:[{n:'Migreringsplan',i:'\u{1F4CB}',c:48},{n:'Testresultat',i:'\u{1F9EA}',c:34},{n:'Guider',i:'\u{1F4DD}',c:30}],visited:true,activity:'high',desc:'Migrering till Microsoft 365 â€“ planer och testresultat.'},
  {id:'arkiv',name:'Centralt Arkiv',emoji:'\u{1F5C4}\uFE0F',type:'dept',group:'standalone',hubId:null,x:-1000,y:-350,rx:85,ry:52,terrain:'desert',docs:345,
   libs:[{n:'Historik',i:'\u{1F5C4}\uFE0F',c:180},{n:'Avtal',i:'\u{1F4DC}',c:95},{n:'Korrespondens',i:'\u2709\uFE0F',c:70}],visited:true,activity:'low',desc:'Centralt dokumentarkiv med historiska dokument.'},
  {id:'utbild',name:'Utbildningsportalen',emoji:'\u{1F393}',type:'dept',group:'standalone',hubId:null,x:0,y:900,rx:60,ry:37,terrain:'tropical',docs:78,
   libs:[{n:'Kursmaterial',i:'\u{1F393}',c:42},{n:'E-learning',i:'\u{1F4BB}',c:36}],visited:false,activity:'medium',desc:'Utbildningsmaterial och e-learningresurser.'},
  {id:'kvalitet',name:'Kvalitet & Process',emoji:'\u2705',type:'dept',group:'standalone',hubId:null,x:-350,y:780,rx:58,ry:36,terrain:'forest',docs:93,
   libs:[{n:'Processkartor',i:'\u{1F5FA}\uFE0F',c:38},{n:'Rutiner',i:'\u{1F4CC}',c:32},{n:'Revisioner',i:'\u{1F50D}',c:23}],visited:true,activity:'medium',desc:'Kvalitetsledning, processkartor och rutiner.'},
  {id:'risk',name:'Riskhantering',emoji:'\u26A0\uFE0F',type:'dept',group:'standalone',hubId:null,x:380,y:350,rx:70,ry:43,terrain:'volcanic',docs:167,
   libs:[{n:'Riskregister',i:'\u26A0\uFE0F',c:62},{n:'Scenarioanalyser',i:'\u{1F4CA}',c:55},{n:'Policyer',i:'\u{1F4CB}',c:50}],visited:true,activity:'high',desc:'Riskregister, scenarioanalyser och riskpolicyer.'},
  {id:'miljo',name:'Milj\u00f6 & H\u00e5llbarhet',emoji:'\u{1F33F}',type:'dept',group:'standalone',hubId:null,x:-1000,y:200,rx:48,ry:30,terrain:'forest',docs:41,
   libs:[{n:'H\u00e5llbarhetsrapporter',i:'\u{1F33F}',c:22},{n:'Policyer',i:'\u{1F4CB}',c:19}],visited:false,activity:'low',desc:'H\u00e5llbarhetsrapporter och milj\u00f6policyer.'},
  {id:'intro',name:'Onboarding & Introduktion',emoji:'\u{1F392}',type:'dept',group:'standalone',hubId:null,x:400,y:-200,rx:50,ry:32,terrain:'meadow',docs:56,
   libs:[{n:'Introduktionspaket',i:'\u{1F392}',c:28},{n:'Checklistor',i:'\u2705',c:28}],visited:true,activity:'medium',desc:'Introduktionspaket och checklistor f\u00f6r nyanst\u00e4llda.'},
  {id:'intranat',name:'Intranat-redaktionen',emoji:'\u{1F4F0}',type:'dept',group:'standalone',hubId:null,x:-120,y:-450,rx:48,ry:30,terrain:'meadow',docs:38,
   libs:[{n:'Mallar',i:'\u{1F4DD}',c:20},{n:'Guider',i:'\u{1F4D6}',c:18}],visited:true,activity:'low',desc:'Intranatmallar och publiceringsguider.'},
  {id:'forskning',name:'Omv\u00e4rldsbevakning',emoji:'\u{1F52C}',type:'dept',group:'standalone',hubId:null,x:300,y:-500,rx:56,ry:35,terrain:'snow',docs:72,
   libs:[{n:'Rapporter',i:'\u{1F4CA}',c:38},{n:'Trender',i:'\u{1F4C8}',c:34}],visited:true,activity:'medium',desc:'Omv\u00e4rldsbevakning, trendrapporter och branschanalyser.'},
  {id:'leverantor',name:'Leverant\u00f6rsportal',emoji:'\u{1F91D}',type:'dept',group:'standalone',hubId:null,x:-400,y:600,rx:52,ry:33,terrain:'desert',docs:48,
   libs:[{n:'Avtal',i:'\u{1F91D}',c:28},{n:'Utv\u00e4rderingar',i:'\u{1F4CA}',c:20}],visited:false,activity:'low',desc:'Leverant\u00f6rsavtal och utv\u00e4rderingar.'},
  {id:'krisplan',name:'Krishantering & BCP',emoji:'\u{1F6A8}',type:'dept',group:'standalone',hubId:null,x:500,y:720,rx:45,ry:28,terrain:'volcanic',docs:29,
   libs:[{n:'Krisplaner',i:'\u{1F6A8}',c:15},{n:'Kontaktlistor',i:'\u{1F4DE}',c:14}],visited:false,activity:'low',desc:'Krishanteringsplaner och kontaktlistor.'},
  {id:'projhub',name:'Projektportalen',emoji:'\u{1F4C1}',type:'dept',group:'standalone',hubId:null,x:-300,y:-650,rx:55,ry:34,terrain:'rocky',docs:67,
   libs:[{n:'Projektmallar',i:'\u{1F4CB}',c:32},{n:'Statusrapporter',i:'\u{1F4CA}',c:35}],visited:true,activity:'medium',desc:'Central projektportal med mallar och statusrapporter.'},
  {id:'marknad',name:'Marknad & Analys',emoji:'\u{1F4E3}',type:'dept',group:'standalone',hubId:null,x:550,y:-100,rx:58,ry:36,terrain:'tropical',docs:83,
   libs:[{n:'Marknadsanalyser',i:'\u{1F4CA}',c:42},{n:'Kampanjmaterial',i:'\u{1F4E3}',c:41}],visited:true,activity:'medium',desc:'Marknadsanalyser och kampanjmaterial.'},
  {id:'utredning',name:'Utredning & Analys',emoji:'\u{1F50E}',type:'dept',group:'standalone',hubId:null,x:380,y:850,rx:52,ry:33,terrain:'marsh',docs:61,
   libs:[{n:'Utredningar',i:'\u{1F50E}',c:32},{n:'Sammanst\u00e4llningar',i:'\u{1F4CB}',c:29}],visited:false,activity:'low',desc:'Utredningar och analytiska sammanst\u00e4llningar.'},
  {id:'aktuarie',name:'Aktuarieavdelningen',emoji:'\u{1F4D0}',type:'dept',group:'standalone',hubId:null,x:-480,y:-150,rx:60,ry:37,terrain:'snow',docs:156,
   libs:[{n:'Ber\u00e4kningsmodeller',i:'\u{1F4D0}',c:68},{n:'Rapporter',i:'\u{1F4CA}',c:48},{n:'Antaganden',i:'\u{1F4CB}',c:40}],visited:true,activity:'high',desc:'Koncerngemensam aktuarieavdelning med ber\u00e4kningsmodeller.'}
];

// Assign user counts per site (seeded for consistency)
islands.forEach((isl, i) => {
  const rng = lcg(i * 31 + 77);
  if (isl.type === 'hub') isl.users = 20 + Math.floor(rng() * 25);
  else if (isl.type === 'satellite') isl.users = 5 + Math.floor(rng() * 15);
  else if (isl.type === 'project') isl.users = 4 + Math.floor(rng() * 8);
  else isl.users = 3 + Math.floor(rng() * 12);
});

// ========== STATE ==========
let scale = 0.55, panX = 0, panY = 0;
let isPanning = false, panStartX = 0, panStartY = 0, panStartPX = 0, panStartPY = 0;
let selectedIsland = null;
let shipAnim = null;

// Drag / edit mode state
let editMode = false;
let isDragging = false;
let dragIsland = null;
let dragStartMX = 0, dragStartMY = 0;
let dragOrigX = 0, dragOrigY = 0;
let dragMoved = false;

// Store default positions for reset
const defaultPositions = {};
islands.forEach(isl => { defaultPositions[isl.id] = {x: isl.x, y: isl.y}; });
const container = document.getElementById('map-container');
const svg = document.getElementById('map-svg');
const detailPanel = document.getElementById('detail-panel');
const shipEl = document.getElementById('ship');
const minimapCanvas = document.getElementById('minimap-canvas');
const minimapCtx = minimapCanvas.getContext('2d');

// ========== LAYOUT SAVE / LOAD ==========
function saveLayout() {
  const positions = {};
  islands.forEach(isl => { positions[isl.id] = {x: isl.x, y: isl.y}; });
  localStorage.setItem('dina-skargard-layout-v2', JSON.stringify(positions));
  const ind = document.getElementById('saveIndicator');
  ind.classList.add('show');
  setTimeout(() => ind.classList.remove('show'), 1800);
}

function loadLayout() {
  try {
    const saved = JSON.parse(localStorage.getItem('dina-skargard-layout-v2'));
    if (saved) {
      let applied = 0;
      islands.forEach(isl => {
        if (saved[isl.id]) { isl.x = saved[isl.id].x; isl.y = saved[isl.id].y; applied++; }
      });
      if (applied > 0) return true;
    }
  } catch(e) {}
  return false;
}

function resetLayout() {
  islands.forEach(isl => {
    isl.x = defaultPositions[isl.id].x;
    isl.y = defaultPositions[isl.id].y;
  });
  localStorage.removeItem('dina-skargard-layout-v2');
  buildMap();
  addAnimations();
  showToast('Layout Ã¥terstÃ¤lld till original');
}

function rebuildBridges() {
  const bridgeLayer = svg.querySelector('#bridge-layer');
  if (!bridgeLayer) return;
  bridgeLayer.innerHTML = '';
  const hubMap = {};
  islands.forEach(i => { if (i.type === 'hub') hubMap[i.id] = i; });
  islands.forEach(i => {
    if (i.hubId && hubMap[i.hubId]) {
      drawBridge(bridgeLayer, hubMap[i.hubId], i);
    }
  });
}

// ========== EDIT MODE ==========
function setEditMode(on) {
  editMode = on;
  document.body.classList.toggle('edit-mode', on);
  document.getElementById('btnNavigate').classList.toggle('active', !on);
  document.getElementById('btnArrange').classList.toggle('active', on);
  if (on) {
    showToast('ArrangeringslÃ¤ge â€“ dra Ã¶ar fÃ¶r att flytta dem');
    detailPanel.classList.remove('open');
    selectedIsland = null;
  } else {
    showToast('NavigeringslÃ¤ge â€“ klicka pÃ¥ en Ã¶ fÃ¶r att utforska');
  }
}

// ========== HELPERS ==========
function worldToScreen(wx, wy) {
  const cw = container.clientWidth, ch = container.clientHeight;
  return { x: cw / 2 + wx * scale + panX, y: ch / 2 + wy * scale + panY };
}
function screenToWorld(sx, sy) {
  const cw = container.clientWidth, ch = container.clientHeight;
  return { x: (sx - cw / 2 - panX) / scale, y: (sy - ch / 2 - panY) / scale };
}

function showToast(msg) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.add('show');
  clearTimeout(t._to);
  t._to = setTimeout(() => t.classList.remove('show'), 2200);
}

// ========== LCG PRNG ==========
function lcg(seed) {
  let s = seed | 0;
  return () => { s = (s * 1664525 + 1013904223) & 0xffffffff; return (s >>> 0) / 0xffffffff; };
}

// ========== BLOB PATH (Catmull-Rom to Bezier) ==========
function blobPath(cx, cy, rx, ry, seed, numPoints) {
  numPoints = numPoints || 12;
  const rng = lcg(seed);
  const pts = [];
  for (let i = 0; i < numPoints; i++) {
    const a = (i / numPoints) * Math.PI * 2;
    const jitter = 0.7 + rng() * 0.6;
    pts.push({
      x: cx + Math.cos(a) * rx * jitter,
      y: cy + Math.sin(a) * ry * jitter * 0.65
    });
  }
  let d = '';
  for (let i = 0; i < pts.length; i++) {
    const p0 = pts[(i - 1 + pts.length) % pts.length];
    const p1 = pts[i];
    const p2 = pts[(i + 1) % pts.length];
    const p3 = pts[(i + 2) % pts.length];
    if (i === 0) d += 'M' + p1.x.toFixed(1) + ',' + p1.y.toFixed(1);
    const cp1x = p1.x + (p2.x - p0.x) / 6;
    const cp1y = p1.y + (p2.y - p0.y) / 6;
    const cp2x = p2.x - (p3.x - p1.x) / 6;
    const cp2y = p2.y - (p3.y - p1.y) / 6;
    d += ' C' + cp1x.toFixed(1) + ',' + cp1y.toFixed(1) + ' ' + cp2x.toFixed(1) + ',' + cp2y.toFixed(1) + ' ' + p2.x.toFixed(1) + ',' + p2.y.toFixed(1);
  }
  return d + 'Z';
}

// ========== SVG ELEMENT BUILDER ==========
function svgEl(tag, attrs, textContent) {
  const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
  for (const [k, v] of Object.entries(attrs || {})) {
    el.setAttribute(k, v);
  }
  if (textContent !== undefined) el.textContent = textContent;
  return el;
}

// ========== BUILD DEFS ==========
function buildDefs() {
  const defs = svgEl('defs');

  // Ocean radial gradient â€” warmer center, dark edges
  const og = svgEl('radialGradient', {id:'oceanGrad', cx:'45%', cy:'40%', r:'70%'});
  og.appendChild(svgEl('stop', {offset:'0%', 'stop-color':'#48b8a8'}));
  og.appendChild(svgEl('stop', {offset:'20%', 'stop-color':'#38a898'}));
  og.appendChild(svgEl('stop', {offset:'50%', 'stop-color':'#2a9080'}));
  og.appendChild(svgEl('stop', {offset:'80%', 'stop-color':'#1e7a6a'}));
  og.appendChild(svgEl('stop', {offset:'100%', 'stop-color':'#146858'}));
  defs.appendChild(og);

  // Deep trench gradient (dark zones) â€” very noticeable
  const tg = svgEl('radialGradient', {id:'trenchGrad', cx:'50%', cy:'50%', r:'50%'});
  tg.appendChild(svgEl('stop', {offset:'0%', 'stop-color':'#0a4040', 'stop-opacity':'0.35'}));
  tg.appendChild(svgEl('stop', {offset:'50%', 'stop-color':'#0e4848', 'stop-opacity':'0.15'}));
  tg.appendChild(svgEl('stop', {offset:'100%', 'stop-color':'#125050', 'stop-opacity':'0'}));
  defs.appendChild(tg);

  // Shallow warm gradient (lighter zones between islands) â€” prominent
  const sg = svgEl('radialGradient', {id:'shallowGrad', cx:'50%', cy:'50%', r:'50%'});
  sg.appendChild(svgEl('stop', {offset:'0%', 'stop-color':'#60d8c8', 'stop-opacity':'0.5'}));
  sg.appendChild(svgEl('stop', {offset:'40%', 'stop-color':'#48c8b8', 'stop-opacity':'0.25'}));
  sg.appendChild(svgEl('stop', {offset:'100%', 'stop-color':'#38b8a8', 'stop-opacity':'0'}));
  defs.appendChild(sg);

  // Turquoise warm spot gradient â€” clearly visible
  const tsg = svgEl('radialGradient', {id:'warmSpotGrad', cx:'50%', cy:'50%', r:'50%'});
  tsg.appendChild(svgEl('stop', {offset:'0%', 'stop-color':'#68e0c8', 'stop-opacity':'0.35'}));
  tsg.appendChild(svgEl('stop', {offset:'50%', 'stop-color':'#50c8b8', 'stop-opacity':'0.18'}));
  tsg.appendChild(svgEl('stop', {offset:'100%', 'stop-color':'#40b8a8', 'stop-opacity':'0'}));
  defs.appendChild(tsg);

  // Caustic light pattern â€” brighter and more visible
  const cp = svgEl('pattern', {id:'causticPattern', width:'150', height:'150', patternUnits:'userSpaceOnUse'});
  const cpRng = lcg(42);
  for (let i = 0; i < 30; i++) {
    const cr = 1.5 + cpRng() * 3;
    cp.appendChild(svgEl('circle', {
      cx: String(cpRng() * 150), cy: String(cpRng() * 150), r: String(cr),
      fill: 'rgba(160,210,255,' + (0.04 + cpRng() * 0.06).toFixed(3) + ')'
    }));
  }
  // Add some elongated light streaks
  for (let i = 0; i < 8; i++) {
    const sx = cpRng() * 150, sy = cpRng() * 150;
    const angle = cpRng() * Math.PI;
    const len = 8 + cpRng() * 15;
    cp.appendChild(svgEl('line', {
      x1: String(sx), y1: String(sy),
      x2: String(sx + Math.cos(angle) * len), y2: String(sy + Math.sin(angle) * len),
      stroke: 'rgba(140,200,255,0.04)', 'stroke-width': String(0.8 + cpRng() * 1.2), 'stroke-linecap': 'round'
    }));
  }
  defs.appendChild(cp);

  // Hex pattern
  const hp = svgEl('pattern', {id:'hexPattern', width:'52', height:'60', patternUnits:'userSpaceOnUse'});
  hp.appendChild(svgEl('path', {d:'M26 0 L52 15 L52 45 L26 60 L0 45 L0 15 Z', fill:'none', stroke:'rgba(100,180,255,0.025)', 'stroke-width':'0.5'}));
  defs.appendChild(hp);

  // Wave pattern â€” two layers with animated drift
  const wp = svgEl('pattern', {id:'wavePattern', width:'120', height:'35', patternUnits:'userSpaceOnUse'});
  wp.appendChild(svgEl('path', {d:'M0 14 Q15 6 30 14 Q45 22 60 14 Q75 6 90 14 Q105 22 120 14', fill:'none', stroke:'rgba(255,255,255,0.18)', 'stroke-width':'1.2'}));
  wp.appendChild(svgEl('path', {d:'M0 24 Q15 16 30 24 Q45 32 60 24 Q75 16 90 24 Q105 32 120 24', fill:'none', stroke:'rgba(255,255,255,0.12)', 'stroke-width':'0.9'}));
  wp.appendChild(svgEl('path', {d:'M10 8 Q25 2 40 8 Q55 14 70 8 Q85 2 100 8', fill:'none', stroke:'rgba(255,255,255,0.14)', 'stroke-width':'0.7'}));
  // Animate pattern tile offset for wave drift
  const waveAnim = svgEl('animateTransform', {attributeName:'patternTransform', type:'translate', from:'0 0', to:'120 0', dur:'20s', repeatCount:'indefinite'});
  wp.appendChild(waveAnim);
  defs.appendChild(wp);

  // Large swell pattern with animated drift
  const swp = svgEl('pattern', {id:'swellPattern', width:'250', height:'60', patternUnits:'userSpaceOnUse'});
  swp.appendChild(svgEl('path', {d:'M0 30 Q30 10 62 30 Q95 50 125 30 Q158 10 190 30 Q220 50 250 30', fill:'none', stroke:'rgba(90,180,235,0.08)', 'stroke-width':'2.5'}));
  swp.appendChild(svgEl('path', {d:'M20 45 Q55 28 90 45 Q125 62 160 45 Q195 28 230 45', fill:'none', stroke:'rgba(70,160,220,0.06)', 'stroke-width':'1.8'}));
  const swellDrift = svgEl('animateTransform', {attributeName:'patternTransform', type:'translate', from:'0 0', to:'250 3', dur:'35s', repeatCount:'indefinite'});
  swp.appendChild(swellDrift);
  defs.appendChild(swp);

  // Foam current pattern (white wispy lines)
  const fcp = svgEl('pattern', {id:'foamPattern', width:'200', height:'100', patternUnits:'userSpaceOnUse'});
  const fcRng = lcg(99);
  for (let i = 0; i < 5; i++) {
    const y = 10 + fcRng() * 80;
    const cp1x = 30 + fcRng() * 40, cp1y = y + (fcRng() - 0.5) * 30;
    const cp2x = 120 + fcRng() * 40, cp2y = y + (fcRng() - 0.5) * 30;
    fcp.appendChild(svgEl('path', {
      d: 'M0,' + y.toFixed(0) + ' C' + cp1x.toFixed(0) + ',' + cp1y.toFixed(0) + ' ' + cp2x.toFixed(0) + ',' + cp2y.toFixed(0) + ' 200,' + (y + (fcRng() - 0.5) * 20).toFixed(0),
      fill: 'none', stroke: 'rgba(255,255,255,0.02)', 'stroke-width': String(0.5 + fcRng() * 1), 'stroke-linecap': 'round'
    }));
  }
  defs.appendChild(fcp);

  // Island shadow filter
  const sf = svgEl('filter', {id:'islandShadow', x:'-30%', y:'-20%', width:'160%', height:'160%'});
  sf.appendChild(svgEl('feGaussianBlur', {'in':'SourceAlpha', stdDeviation:'8', result:'blur'}));
  sf.appendChild(svgEl('feOffset', {'in':'blur', dx:'4', dy:'8', result:'offsetBlur'}));
  sf.appendChild(svgEl('feFlood', {'flood-color':'rgba(0,0,0,0.35)', result:'color'}));
  sf.appendChild(svgEl('feComposite', {'in':'color', in2:'offsetBlur', operator:'in', result:'shadow'}));
  const sfMerge = svgEl('feMerge');
  sfMerge.appendChild(svgEl('feMergeNode', {'in':'shadow'}));
  sfMerge.appendChild(svgEl('feMergeNode', {'in':'SourceGraphic'}));
  sf.appendChild(sfMerge);
  defs.appendChild(sf);

  // Hub glow filter
  const hg = svgEl('filter', {id:'hubGlow', x:'-40%', y:'-40%', width:'180%', height:'180%'});
  hg.appendChild(svgEl('feGaussianBlur', {'in':'SourceAlpha', stdDeviation:'12', result:'blur'}));
  hg.appendChild(svgEl('feFlood', {'flood-color':'rgba(212,168,67,0.5)', result:'color'}));
  hg.appendChild(svgEl('feComposite', {'in':'color', in2:'blur', operator:'in', result:'glow'}));
  const hgMerge = svgEl('feMerge');
  hgMerge.appendChild(svgEl('feMergeNode', {'in':'glow'}));
  hgMerge.appendChild(svgEl('feMergeNode', {'in':'SourceGraphic'}));
  hg.appendChild(hgMerge);
  defs.appendChild(hg);

  // Fog filter
  const ff = svgEl('filter', {id:'fogFilter', x:'-15%', y:'-15%', width:'130%', height:'130%'});
  ff.appendChild(svgEl('feGaussianBlur', {'in':'SourceGraphic', stdDeviation:'4'}));
  ff.appendChild(svgEl('feColorMatrix', {type:'saturate', values:'0.2'}));
  defs.appendChild(ff);

  // Per-terrain island gradients
  for (const [tname, tc] of Object.entries(TERRAIN)) {
    const gr = svgEl('radialGradient', {id:'islandGrad-' + tname, cx:'40%', cy:'35%', r:'65%'});
    gr.appendChild(svgEl('stop', {offset:'0%', 'stop-color': tc.light}));
    gr.appendChild(svgEl('stop', {offset:'60%', 'stop-color': tc.base}));
    gr.appendChild(svgEl('stop', {offset:'100%', 'stop-color': tc.deep}));
    defs.appendChild(gr);
  }

  // --- Atmosphere gradients ---
  const vignetteGrad = svgEl('radialGradient', {id:'vignetteGrad', cx:'50%', cy:'45%', r:'70%'});
  vignetteGrad.appendChild(svgEl('stop', {offset:'0%', 'stop-color':'rgba(4,15,30,0)', 'stop-opacity':'0'}));
  vignetteGrad.appendChild(svgEl('stop', {offset:'60%', 'stop-color':'rgba(4,15,30,0.02)', 'stop-opacity':'0.02'}));
  vignetteGrad.appendChild(svgEl('stop', {offset:'85%', 'stop-color':'rgba(4,15,30,0.1)', 'stop-opacity':'0.1'}));
  vignetteGrad.appendChild(svgEl('stop', {offset:'100%', 'stop-color':'rgba(4,15,30,0.25)', 'stop-opacity':'0.25'}));
  defs.appendChild(vignetteGrad);

  return defs;
}

// ========== BUILD ATMOSPHERE ==========
function buildAtmosphere() {
  const g = svgEl('g', {class:'atmosphere', 'pointer-events':'none'});

  // Vignette overlay
  g.appendChild(svgEl('rect', {x:'-5000', y:'-5000', width:'10000', height:'10000', fill:'url(#vignetteGrad)'}));

  // God-rays from top-left
  const rayOX = -1200, rayOY = -800;
  [{a:18,l:2200,hw:55},{a:32,l:2400,hw:70},{a:48,l:2000,hw:40},{a:62,l:2100,hw:75}].forEach(ray => {
    const rad = ray.a * Math.PI / 180;
    const dx = Math.cos(rad), dy = Math.sin(rad);
    const px = -dy, py = dx;
    const fx = rayOX + dx * ray.l, fy = rayOY + dy * ray.l;
    g.appendChild(svgEl('polygon', {
      points: rayOX + ',' + rayOY + ' ' + (fx + px * ray.hw).toFixed(1) + ',' + (fy + py * ray.hw).toFixed(1) + ' ' + (fx - px * ray.hw).toFixed(1) + ',' + (fy - py * ray.hw).toFixed(1),
      fill: 'rgba(255,240,180,0.025)'
    }));
  });

  // Distance fog (peripheral haze)
  [{cx:-900,cy:-500,rx:380,ry:260,o:0.06},{cx:1000,cy:-300,rx:350,ry:240,o:0.055},{cx:-800,cy:600,rx:320,ry:220,o:0.05},{cx:900,cy:700,rx:400,ry:280,o:0.06},{cx:200,cy:-650,rx:360,ry:200,o:0.04},{cx:-400,cy:800,rx:340,ry:250,o:0.045}].forEach(f => {
    g.appendChild(svgEl('ellipse', {cx:String(f.cx), cy:String(f.cy), rx:String(f.rx), ry:String(f.ry), fill:'rgba(100,140,180,' + f.o + ')'}));
  });

  // Warm golden tint
  g.appendChild(svgEl('rect', {x:'-5000', y:'-5000', width:'10000', height:'10000', fill:'rgba(255,220,150,0.015)'}));

  return g;
}

// ========== BUILD OCEAN ==========
function buildOcean() {
  const g = svgEl('g', {id:'ocean-layer'});
  const W = 5000;

  // Base gradient
  g.appendChild(svgEl('rect', {x:String(-W), y:String(-W), width:String(W*2), height:String(W*2), fill:'url(#oceanGrad)'}));

  // --- Depth zones: deep trenches (dark patches) ---
  const trenches = [
    {x:-800, y:-200, rx:350, ry:180},
    {x:400, y:100, rx:280, ry:220},
    {x:-200, y:600, rx:400, ry:150},
    {x:900, y:-400, rx:250, ry:300},
    {x:-600, y:-600, rx:200, ry:200},
  ];
  trenches.forEach(t => {
    g.appendChild(svgEl('ellipse', {cx:String(t.x), cy:String(t.y), rx:String(t.rx), ry:String(t.ry), fill:'url(#trenchGrad)'}));
  });

  // --- Shallow warm zones (turquoise patches between island clusters) ---
  const shallows = [
    {x:0, y:0, rx:250, ry:200},      // center (around Koncernledning)
    {x:-650, y:-450, rx:280, ry:200}, // around Dina AB cluster
    {x:700, y:-400, rx:250, ry:180},  // around Lantbruk cluster
    {x:750, y:500, rx:220, ry:160},   // around Liv cluster
    {x:-700, y:500, rx:260, ry:190},  // around IT cluster
    {x:50, y:600, rx:230, ry:170},    // around Ekonomi cluster
  ];
  shallows.forEach(s => {
    g.appendChild(svgEl('ellipse', {cx:String(s.x), cy:String(s.y), rx:String(s.rx), ry:String(s.ry), fill:'url(#shallowGrad)'}));
  });

  // --- Warm turquoise spots (smaller, scattered for color variation) ---
  const warmRng = lcg(777);
  for (let i = 0; i < 15; i++) {
    const wx = (warmRng() - 0.5) * 2400;
    const wy = (warmRng() - 0.5) * 1800;
    const wrx = 80 + warmRng() * 180;
    const wry = 60 + warmRng() * 140;
    g.appendChild(svgEl('ellipse', {cx:String(wx), cy:String(wy), rx:String(wrx), ry:String(wry), fill:'url(#warmSpotGrad)'}));
  }

  // --- Sea current flow lines (long curved paths showing water movement) ---
  const currents = [
    {d:'M-1200,-300 C-800,-350 -400,-200 0,-250 C400,-300 800,-150 1200,-200', color:'rgba(100,190,230,0.14)', w:5},
    {d:'M-1100,200 C-700,150 -300,300 100,250 C500,200 800,350 1200,300', color:'rgba(80,180,220,0.12)', w:4},
    {d:'M-1000,-600 C-600,-550 -200,-650 200,-600 C600,-550 900,-680 1200,-620', color:'rgba(90,185,225,0.1)', w:3.5},
    {d:'M-1200,600 C-800,550 -400,680 0,620 C400,560 800,650 1200,600', color:'rgba(70,170,210,0.11)', w:4},
    {d:'M-800,800 C-400,750 0,850 400,800 C700,750 900,830 1100,780', color:'rgba(100,200,240,0.09)', w:3},
    {d:'M-1100,-100 C-700,0 -300,-150 100,-50 C500,50 900,-80 1200,20', color:'rgba(120,210,250,0.08)', w:3.5},
  ];
  currents.forEach(c => {
    g.appendChild(svgEl('path', {d:c.d, fill:'none', stroke:c.color, 'stroke-width':String(c.w), 'stroke-linecap':'round'}));
  });

  // --- Foam / white water streaks ---
  const foamRng = lcg(333);
  for (let i = 0; i < 35; i++) {
    const fx = (foamRng() - 0.5) * 2400;
    const fy = (foamRng() - 0.5) * 1800;
    const flen = 80 + foamRng() * 300;
    const fangle = foamRng() * Math.PI * 0.6 - 0.3;
    const fcx = fx + Math.cos(fangle) * flen * 0.4;
    const fcy = fy + Math.sin(fangle) * flen * 0.3 + (foamRng() - 0.5) * 50;
    const fex = fx + Math.cos(fangle) * flen;
    const fey = fy + Math.sin(fangle) * flen * 0.6;
    g.appendChild(svgEl('path', {
      d: 'M' + fx.toFixed(0) + ',' + fy.toFixed(0) + ' Q' + fcx.toFixed(0) + ',' + fcy.toFixed(0) + ' ' + fex.toFixed(0) + ',' + fey.toFixed(0),
      fill:'none', stroke:'rgba(200,230,255,0.06)', 'stroke-width':String(1 + foamRng() * 2.5), 'stroke-linecap':'round'
    }));
  }

  // --- Pattern overlays ---
  // Caustic lights
  const causticRect = svgEl('rect', {x:String(-W), y:String(-W), width:String(W*2), height:String(W*2), fill:'url(#causticPattern)'});
  // SMIL opacity pulse
  const causticAnim = svgEl('animate', {attributeName:'opacity', values:'0.6;1;0.6', dur:'8s', repeatCount:'indefinite'});
  causticRect.appendChild(causticAnim);
  g.appendChild(causticRect);
  // Hex grid
  g.appendChild(svgEl('rect', {x:String(-W), y:String(-W), width:String(W*2), height:String(W*2), fill:'url(#hexPattern)'}));
  // Wave ripples
  g.appendChild(svgEl('rect', {x:String(-W), y:String(-W), width:String(W*2), height:String(W*2), fill:'url(#wavePattern)'}));
  // Large swells
  g.appendChild(svgEl('rect', {x:String(-W), y:String(-W), width:String(W*2), height:String(W*2), fill:'url(#swellPattern)'}));
  // Foam current overlay
  g.appendChild(svgEl('rect', {x:String(-W), y:String(-W), width:String(W*2), height:String(W*2), fill:'url(#foamPattern)'}));

  // --- Sunlight sparkles on water surface (SMIL animated) ---
  const sparkleG = svgEl('g', {id:'sparkle-layer'});
  const sparkRng = lcg(555);
  for (let i = 0; i < 15; i++) {
    const sx = (sparkRng() - 0.5) * 2400;
    const sy = (sparkRng() - 0.5) * 1800;
    const delay = (sparkRng() * 8).toFixed(1) + 's';
    const dur = (4 + sparkRng() * 5).toFixed(1) + 's';
    const sparkle = svgEl('circle', {cx:String(sx), cy:String(sy), r:'1', fill:'rgba(255,255,240,0.8)', opacity:'0'});
    sparkle.appendChild(svgEl('animate', {attributeName:'opacity', values:'0;0.8;0.5;0', dur:dur, begin:delay, repeatCount:'indefinite'}));
    sparkle.appendChild(svgEl('animate', {attributeName:'r', values:'1;3;2.5;1', dur:dur, begin:delay, repeatCount:'indefinite'}));
    sparkleG.appendChild(sparkle);
  }
  g.appendChild(sparkleG);

  // --- Shipping lanes between hub-satellite pairs ---
  const laneG = svgEl('g', {id:'shipping-lanes'});
  islands.forEach(sat => {
    if (!sat.hubId) return;
    const hub = islands.find(h => h.id === sat.hubId);
    if (!hub) return;
    const ldx = sat.x - hub.x, ldy = sat.y - hub.y;
    const ldist = Math.sqrt(ldx * ldx + ldy * ldy);
    if (ldist === 0) return;
    const perpX = (-ldy / ldist) * 15, perpY = (ldx / ldist) * 15;
    laneG.appendChild(svgEl('path', {
      d: 'M' + (hub.x + perpX).toFixed(1) + ',' + (hub.y + perpY).toFixed(1) + ' L' + (sat.x + perpX).toFixed(1) + ',' + (sat.y + perpY).toFixed(1),
      fill: 'none', stroke: 'rgba(180,210,240,0.06)', 'stroke-width': '1', 'stroke-dasharray': '2 6', 'stroke-linecap': 'round'
    }));
  });
  g.appendChild(laneG);

  // --- Decorative boats ---
  const boatG = svgEl('g', {id:'decorative-boats'});
  [{x:-400,y:-100,rot:25},{x:200,y:400,rot:-15},{x:800,y:-200,rot:10}].forEach(bp => {
    const boat = svgEl('g', {transform:'translate(' + bp.x + ',' + bp.y + ') rotate(' + bp.rot + ')', opacity:'0.5'});
    boat.appendChild(svgEl('path', {d:'M-4,0 Q-3,-2 0,-2.5 Q3,-2 4,0 Q2,1.5 -2,1.5 Z', fill:'#6b4226', stroke:'#4a2e14', 'stroke-width':'0.3'}));
    boat.appendChild(svgEl('line', {x1:'0',y1:'-2.5',x2:'0',y2:'-10', stroke:'#5a3a1a','stroke-width':'0.6','stroke-linecap':'round'}));
    boat.appendChild(svgEl('path', {d:'M0,-9.5 L0,-3 L4,-5 Z', fill:'rgba(255,255,255,0.85)', stroke:'rgba(200,200,200,0.5)', 'stroke-width':'0.3'}));
    boat.appendChild(svgEl('path', {d:'M0,-10 L2.5,-9 L0,-8', fill:'rgba(180,60,60,0.7)'}));
    boatG.appendChild(boat);
  });
  g.appendChild(boatG);

  // --- Whirlpool effects near deep trenches ---
  const whirlG = svgEl('g', {id:'whirlpool-effects'});
  [{x:-800,y:-200},{x:400,y:100}].forEach(wp => {
    [30,50,70].forEach((r, i) => {
      const opac = [0.08, 0.05, 0.03][i];
      const sa = Math.PI * 0.2 * (i + 1);
      const sw = Math.PI * 1.5;
      whirlG.appendChild(svgEl('path', {
        d: 'M' + (wp.x + Math.cos(sa) * r).toFixed(1) + ',' + (wp.y + Math.sin(sa) * r).toFixed(1) + ' A' + r + ',' + r + ' 0 1,1 ' + (wp.x + Math.cos(sa + sw) * r).toFixed(1) + ',' + (wp.y + Math.sin(sa + sw) * r).toFixed(1),
        fill: 'none', stroke: 'rgba(120,180,220,' + opac + ')', 'stroke-width': String(1.5 - i * 0.3), 'stroke-dasharray': '4 3', 'stroke-linecap': 'round'
      }));
    });
  });
  g.appendChild(whirlG);

  // --- Kelp / seaweed patches near island shores ---
  const kelpG = svgEl('g', {id:'kelp-patches'});
  const kelpRng = lcg(456);
  for (let ki = 0; ki < 8; ki++) {
    const isle = islands[Math.floor(kelpRng() * islands.length)];
    for (let s = 0; s < 3 + Math.floor(kelpRng() * 3); s++) {
      const ka = kelpRng() * Math.PI * 2;
      const bx = isle.x + Math.cos(ka) * (isle.rx + 8) + (kelpRng() - 0.5) * 20;
      const by = isle.y + Math.sin(ka) * (isle.ry + 8) * 0.65 + (kelpRng() - 0.5) * 12;
      const klen = 20 + kelpRng() * 20;
      const odx = Math.cos(ka) * klen, ody = Math.sin(ka) * klen * 0.65;
      const wave = (kelpRng() - 0.5) * 14;
      kelpG.appendChild(svgEl('path', {
        d: 'M' + bx.toFixed(1) + ',' + by.toFixed(1) + ' C' + (bx + odx * 0.35 + wave).toFixed(1) + ',' + (by + ody * 0.35 - wave * 0.6).toFixed(1) + ' ' + (bx + odx * 0.7 - wave * 0.5).toFixed(1) + ',' + (by + ody * 0.7 + wave * 0.4).toFixed(1) + ' ' + (bx + odx).toFixed(1) + ',' + (by + ody).toFixed(1),
        fill: 'none', stroke: 'rgba(30,90,50,0.12)', 'stroke-width': (1.2 + kelpRng() * 1.5).toFixed(1), 'stroke-linecap': 'round'
      }));
    }
  }
  g.appendChild(kelpG);

  return g;
}

// ========== DRAW BRIDGE ==========
function drawBridge(g, hub, sat) {
  const dx = sat.x - hub.x, dy = sat.y - hub.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const mx = (hub.x + sat.x) / 2, my = (hub.y + sat.y) / 2;
  const nLen = dist || 1;
  const nx = -dy / nLen, ny = dx / nLen;
  const off = dist * 0.12;
  const bcx = mx + nx * off, bcy = my + ny * off;
  const pathD = 'M' + hub.x + ',' + hub.y + ' Q' + bcx + ',' + bcy + ' ' + sat.x + ',' + sat.y;

  // Evaluate quadratic bezier at parameter t
  function bezAt(t) {
    const u = 1 - t;
    return { x: u * u * hub.x + 2 * u * t * bcx + t * t * sat.x, y: u * u * hub.y + 2 * u * t * bcy + t * t * sat.y };
  }
  // Evenly-spaced t values along arc length
  function evenTValues(spacing) {
    const N = 100; let prev = bezAt(0); const lens = [0];
    for (let i = 1; i <= N; i++) { const pt = bezAt(i / N); lens.push(lens[i - 1] + Math.sqrt((pt.x - prev.x) ** 2 + (pt.y - prev.y) ** 2)); prev = pt; }
    const total = lens[N]; const count = Math.max(1, Math.floor(total / spacing)); const step = total / count; const ts = [];
    for (let j = 0; j <= count; j++) {
      const target = j * step; let lo = 0, hi = N;
      while (lo < hi) { const mid = (lo + hi) >> 1; if (lens[mid] < target) lo = mid + 1; else hi = mid; }
      const s0 = lo > 0 ? lo - 1 : 0, segLen = lens[lo] - lens[s0];
      ts.push(Math.min(1, Math.max(0, (s0 + (segLen > 0 ? (target - lens[s0]) / segLen : 0)) / N)));
    }
    return ts;
  }

  // Shadow
  g.appendChild(svgEl('path', { d: pathD, fill: 'none', stroke: 'rgba(0,0,0,0.18)', 'stroke-width': '6', 'stroke-linecap': 'round', transform: 'translate(3,6)' }));

  if (dist < 250) {
    // SHORT: Wooden plank bridge
    g.appendChild(svgEl('path', { d: pathD, fill: 'none', stroke: '#8B6914', 'stroke-width': '3', 'stroke-dasharray': '10,5', 'stroke-linecap': 'round' }));
    g.appendChild(svgEl('path', { d: pathD, fill: 'none', stroke: '#A0782A', 'stroke-width': '1.2', 'stroke-dasharray': '4,8', 'stroke-linecap': 'round' }));
    evenTValues(40).forEach(t => { const pt = bezAt(t); g.appendChild(svgEl('circle', { cx: String(pt.x), cy: String(pt.y), r: '2.5', fill: '#6B4F1D', stroke: '#4A3510', 'stroke-width': '0.5' })); });
  } else if (dist <= 500) {
    // MEDIUM: Rope bridge
    const deepOff = dist * 0.18;
    const dcx = mx + nx * deepOff, dcy = my + ny * deepOff;
    const ropeD = 'M' + hub.x + ',' + hub.y + ' Q' + dcx + ',' + dcy + ' ' + sat.x + ',' + sat.y;
    function ropeBezAt(t) { const u = 1 - t; return { x: u * u * hub.x + 2 * u * t * dcx + t * t * sat.x, y: u * u * hub.y + 2 * u * t * dcy + t * t * sat.y }; }
    g.appendChild(svgEl('path', { d: ropeD, fill: 'none', stroke: '#7A6232', 'stroke-width': '2', 'stroke-linecap': 'round' }));
    g.appendChild(svgEl('path', { d: pathD, fill: 'none', stroke: '#9A8252', 'stroke-width': '1', 'stroke-dasharray': '6,4', 'stroke-linecap': 'round' }));
    const ropeCount = Math.min(6, Math.max(4, Math.round(dist / 80)));
    for (let r = 1; r <= ropeCount; r++) { const t = r / (ropeCount + 1); const tp = bezAt(t); const bp = ropeBezAt(t); g.appendChild(svgEl('line', { x1: String(tp.x), y1: String(tp.y), x2: String(bp.x), y2: String(bp.y), stroke: '#8A7242', 'stroke-width': '0.8', 'stroke-linecap': 'round' })); }
    evenTValues(50).forEach(t => { const pt = ropeBezAt(t); g.appendChild(svgEl('circle', { cx: String(pt.x), cy: String(pt.y), r: '2.8', fill: '#5C4A20', stroke: '#3E3010', 'stroke-width': '0.5' })); });
  } else {
    // LONG: Stone arch bridge
    g.appendChild(svgEl('path', { d: pathD, fill: 'none', stroke: '#5A5A5A', 'stroke-width': '5.5', 'stroke-linecap': 'round', opacity: '0.3' }));
    g.appendChild(svgEl('path', { d: pathD, fill: 'none', stroke: '#7A7A7A', 'stroke-width': '4', 'stroke-linecap': 'round' }));
    const archCount = dist > 700 ? 3 : 2;
    for (let a = 1; a <= archCount; a++) {
      const t = a / (archCount + 1); const ac = bezAt(t);
      const tanX = 2 * (1 - t) * (bcx - hub.x) + 2 * t * (sat.x - bcx);
      const tanY = 2 * (1 - t) * (bcy - hub.y) + 2 * t * (sat.y - bcy);
      const tLen = Math.sqrt(tanX * tanX + tanY * tanY) || 1;
      const tdx = tanX / tLen, tdy = tanY / tLen;
      const archR = 14 + (dist > 700 ? 4 : 0);
      const asx = ac.x - tdx * archR, asy = ac.y - tdy * archR;
      const aex = ac.x + tdx * archR, aey = ac.y + tdy * archR;
      g.appendChild(svgEl('path', { d: 'M' + asx + ',' + asy + ' A' + archR + ',' + archR + ' 0 0,1 ' + aex + ',' + aey, fill: 'none', stroke: '#6A6A6A', 'stroke-width': '1.5', opacity: '0.7' }));
    }
    evenTValues(60).forEach(t => { const pt = bezAt(t); g.appendChild(svgEl('circle', { cx: String(pt.x), cy: String(pt.y), r: '3.5', fill: '#8A8A8A', stroke: '#5A5A5A', 'stroke-width': '0.7' })); });
  }

  // Endpoint pillars
  const pFill = dist < 250 ? '#6B4F1D' : dist <= 500 ? '#5C4A20' : '#8A8A8A';
  g.appendChild(svgEl('circle', { cx: String(hub.x), cy: String(hub.y), r: '3.5', fill: pFill, stroke: '#333', 'stroke-width': '0.8' }));
  g.appendChild(svgEl('circle', { cx: String(sat.x), cy: String(sat.y), r: '3.5', fill: pFill, stroke: '#333', 'stroke-width': '0.8' }));

  // Flag at hub end
  g.appendChild(svgEl('line', { x1: String(hub.x), y1: String(hub.y), x2: String(hub.x), y2: String(hub.y - 12), stroke: '#8B7332', 'stroke-width': '1', 'stroke-linecap': 'round' }));
  g.appendChild(svgEl('polygon', { points: hub.x + ',' + (hub.y - 12) + ' ' + (hub.x + 5) + ',' + (hub.y - 8) + ' ' + hub.x + ',' + (hub.y - 4), fill: 'rgba(212,168,67,0.7)', stroke: 'rgba(180,140,50,0.5)', 'stroke-width': '0.5' }));
}

// ========== DRAW VEGETATION ==========
function drawVegetation(g, isl, tc, rng) {
  const { rx, ry, terrain } = isl;
  const innerRx = rx * 0.7;
  const innerRy = ry * 0.55;

  switch (terrain) {
    case 'forest': {
      const count = Math.min(14, Math.max(5, Math.floor(rx / 7)));
      // Fallen logs
      const logCount = 1 + Math.floor(rng() * 2);
      for (let i = 0; i < logCount; i++) {
        const lx = (rng() - 0.5) * innerRx * 1.0;
        const ly = (rng() - 0.5) * innerRy * 0.8 + ry * 0.05;
        const lLen = 5 + rng() * 8;
        const lAngle = rng() * Math.PI;
        g.appendChild(svgEl('line', {
          x1: String(lx), y1: String(ly),
          x2: String(lx + Math.cos(lAngle) * lLen), y2: String(ly + Math.sin(lAngle) * lLen * 0.4),
          stroke: '#5a3a18', 'stroke-width': '1.8', 'stroke-linecap': 'round', opacity: '0.45'
        }));
      }
      for (let i = 0; i < count; i++) {
        const angle = rng() * Math.PI * 2;
        const dist = rng() * 0.7;
        const tx = Math.cos(angle) * innerRx * dist;
        const ty = Math.sin(angle) * innerRy * dist - ry * 0.1;
        const h = 8 + rng() * 10;
        const w = 4 + rng() * 4;
        const rot = (rng() - 0.5) * 10;
        // Wrap tree in group; animate every 3rd tree for performance
        const doSway = (i % 3 === 0);
        const swayDeg = doSway ? (0.8 + rng() * 1.2).toFixed(1) : 0;
        const swayDur = doSway ? (4 + rng() * 3).toFixed(1) + 's' : '0s';
        const swayDelay = doSway ? (rng() * 4).toFixed(1) + 's' : '0s';
        const treeG = doSway ? svgEl('g') : g; // only wrap animated trees
        // Deciduous tree (2-3 per island)
        if (i < 3 && rng() > 0.55) {
          treeG.appendChild(svgEl('ellipse', { cx: String(tx), cy: String(ty + 2), rx: String(w * 0.8), ry: String(w * 0.25), fill: '#000', opacity: '0.12' }));
          treeG.appendChild(svgEl('line', { x1: String(tx), y1: String(ty), x2: String(tx), y2: String(ty - h * 0.4), stroke: '#5a3a18', 'stroke-width': '2', 'stroke-linecap': 'round', transform: 'rotate(' + rot + ' ' + tx + ' ' + ty + ')' }));
          const canR = w * 0.9 + rng() * 2;
          const canY = ty - h * 0.55;
          treeG.appendChild(svgEl('circle', { cx: String(tx), cy: String(canY), r: String(canR), fill: tc.base, opacity: '0.8', transform: 'rotate(' + rot + ' ' + tx + ' ' + ty + ')' }));
          treeG.appendChild(svgEl('path', { d: 'M' + (tx - canR) + ',' + canY + ' A' + canR + ',' + canR + ' 0 0,0 ' + (tx + canR) + ',' + canY + ' Z', fill: tc.deep, opacity: '0.4', transform: 'rotate(' + rot + ' ' + tx + ' ' + ty + ')' }));
          if (doSway) {
            treeG.appendChild(svgEl('animateTransform', { attributeName:'transform', type:'rotate', values: '-'+swayDeg+' '+tx+' '+ty+';'+swayDeg+' '+tx+' '+ty+';-'+swayDeg+' '+tx+' '+ty, dur:swayDur, begin:swayDelay, repeatCount:'indefinite' }));
            g.appendChild(treeG);
          }
          continue;
        }
        // Conifer shadow + trunk
        treeG.appendChild(svgEl('ellipse', { cx: String(tx), cy: String(ty + 2), rx: String(w * 0.7), ry: String(w * 0.2), fill: '#000', opacity: '0.15' }));
        treeG.appendChild(svgEl('line', { x1: String(tx), y1: String(ty), x2: String(tx), y2: String(ty + h * 0.3), stroke: '#5a3a18', 'stroke-width': '1.5', 'stroke-linecap': 'round', transform: 'rotate(' + rot + ' ' + tx + ' ' + ty + ')' }));
        // Conifer layers with bezier curves
        const shades = [tc.deep, tc.base, tc.light];
        for (let layer = 0; layer < 3; layer++) {
          const lh = h * (0.5 - layer * 0.12);
          const lw = w * (1 - layer * 0.25);
          const ly = ty - h * 0.15 + layer * h * 0.18;
          const peakY = ly - lh;
          const curveOut = lw * 0.35;
          treeG.appendChild(svgEl('path', {
            d: 'M' + tx + ',' + peakY + ' C' + (tx + curveOut * 0.3) + ',' + (peakY + lh * 0.3) + ' ' + (tx + lw + curveOut * 0.15) + ',' + (ly - lh * 0.15) + ' ' + (tx + lw) + ',' + ly + ' L' + (tx - lw) + ',' + ly + ' C' + (tx - lw - curveOut * 0.15) + ',' + (ly - lh * 0.15) + ' ' + (tx - curveOut * 0.3) + ',' + (peakY + lh * 0.3) + ' ' + tx + ',' + peakY + ' Z',
            fill: shades[layer], opacity: String(0.85 - layer * 0.08), transform: 'rotate(' + rot + ' ' + tx + ' ' + ty + ')'
          }));
        }
        if (doSway) {
          treeG.appendChild(svgEl('animateTransform', { attributeName:'transform', type:'rotate', values: '-'+swayDeg+' '+tx+' '+ty+';'+swayDeg+' '+tx+' '+ty+';-'+swayDeg+' '+tx+' '+ty, dur:swayDur, begin:swayDelay, repeatCount:'indefinite' }));
          g.appendChild(treeG);
        }
      }
      break;
    }
    case 'tropical': {
      const count = Math.min(9, Math.max(3, Math.floor(rx / 9)));
      // Undergrowth bushes
      const bushCount = 3 + Math.floor(rng() * 3);
      for (let b = 0; b < bushCount; b++) {
        const bx = (rng() - 0.5) * innerRx * 1.1;
        const by = (rng() - 0.5) * innerRy * 0.8;
        const br = 2 + rng() * 3;
        g.appendChild(svgEl('circle', { cx: String(bx), cy: String(by), r: String(br), fill: tc.base, opacity: String(0.4 + rng() * 0.2) }));
        g.appendChild(svgEl('circle', { cx: String(bx - br * 0.2), cy: String(by + br * 0.15), r: String(br * 0.6), fill: tc.deep, opacity: '0.3' }));
      }
      for (let i = 0; i < count; i++) {
        const angle = rng() * Math.PI * 2;
        const dist = rng() * 0.65;
        const tx = Math.cos(angle) * innerRx * dist;
        const ty = Math.sin(angle) * innerRy * dist - ry * 0.1;
        const h = 12 + rng() * 10;
        const curve = (rng() - 0.5) * 8;
        // Only animate every 3rd palm for performance
        const doSway = (i % 3 === 0);
        const swayDeg = doSway ? (1 + rng() * 1.5).toFixed(1) : 0;
        const swayDur = doSway ? (3.5 + rng() * 3).toFixed(1) + 's' : '0s';
        const swayDelay = doSway ? (rng() * 4).toFixed(1) + 's' : '0s';
        const palmG = doSway ? svgEl('g') : g;
        palmG.appendChild(svgEl('path', { d: 'M' + tx + ',' + ty + ' Q' + (tx + curve) + ',' + (ty - h * 0.5) + ' ' + (tx + curve * 0.5) + ',' + (ty - h), fill: 'none', stroke: '#7a5a2a', 'stroke-width': '2.5', 'stroke-linecap': 'round' }));
        palmG.appendChild(svgEl('path', { d: 'M' + tx + ',' + ty + ' Q' + (tx + curve) + ',' + (ty - h * 0.5) + ' ' + (tx + curve * 0.5) + ',' + (ty - h), fill: 'none', stroke: '#5a3a1a', 'stroke-width': '0.5', opacity: '0.3' }));
        const topX = tx + curve * 0.5;
        const topY = ty - h;
        const frondCount = 7 + Math.floor(rng() * 2);
        for (let f = 0; f < frondCount; f++) {
          const fa = (f / frondCount) * Math.PI * 2;
          const fl = 7 + rng() * 6;
          const droopY = 3 + rng() * 2;
          const fx = topX + Math.cos(fa) * fl;
          const fy = topY + Math.sin(fa) * fl * 0.6 + droopY;
          const midX = (topX + fx) / 2 + (rng() - 0.5) * 3;
          const midY = (topY + fy) / 2 - 2;
          palmG.appendChild(svgEl('path', { d: 'M' + topX + ',' + topY + ' Q' + midX + ',' + midY + ' ' + fx + ',' + fy, fill: 'none', stroke: tc.base, 'stroke-width': '3', 'stroke-linecap': 'round', opacity: '0.75' }));
          palmG.appendChild(svgEl('path', { d: 'M' + topX + ',' + topY + ' Q' + midX + ',' + midY + ' ' + fx + ',' + fy, fill: 'none', stroke: tc.deep, 'stroke-width': '0.7', 'stroke-linecap': 'round', opacity: '0.5' }));
        }
        if (rng() > 0.5) {
          palmG.appendChild(svgEl('circle', {cx: String(topX + 1), cy: String(topY + 2), r: '1.5', fill: '#8a6a28'}));
          palmG.appendChild(svgEl('circle', {cx: String(topX - 1.5), cy: String(topY + 3), r: '1.2', fill: '#7a5a20'}));
        }
        if (rng() > 0.4) {
          const flowerColors = ['#ff6088', '#ffcc44', '#ff80c0', '#cc44ff'];
          for (let fl = 0; fl < 2 + Math.floor(rng() * 2); fl++) {
            palmG.appendChild(svgEl('circle', { cx: String(tx + (rng() - 0.5) * 5), cy: String(ty + rng() * 2), r: String(0.8 + rng() * 0.8), fill: flowerColors[Math.floor(rng() * flowerColors.length)], opacity: '0.7' }));
          }
        }
        if (doSway) {
          palmG.appendChild(svgEl('animateTransform', { attributeName:'transform', type:'rotate', values: '-'+swayDeg+' '+tx+' '+ty+';'+swayDeg+' '+tx+' '+ty+';-'+swayDeg+' '+tx+' '+ty, dur:swayDur, begin:swayDelay, repeatCount:'indefinite' }));
          g.appendChild(palmG);
        }
      }
      break;
    }
    case 'meadow': {
      const count = Math.min(20, Math.max(8, Math.floor(rx / 4)));
      for (let i = 0; i < count; i++) {
        const angle = rng() * Math.PI * 2;
        const dist = rng() * 0.75;
        const tx = Math.cos(angle) * innerRx * dist;
        const ty = Math.sin(angle) * innerRy * dist;
        const bladeCount = 3 + Math.floor(rng() * 3);
        for (let b = 0; b < bladeCount; b++) {
          const bAngle = (b - bladeCount / 2) * 0.25 + (rng() - 0.5) * 0.3;
          const bLen = 4 + rng() * 4;
          const tipSway = (rng() - 0.5) * 3;
          g.appendChild(svgEl('path', {
            d: 'M' + tx + ',' + ty + ' C' + (tx + tipSway * 0.3) + ',' + (ty - bLen * 0.4) + ' ' + (tx + Math.sin(bAngle) * bLen * 0.5 + tipSway * 0.6) + ',' + (ty - bLen * 0.7) + ' ' + (tx + Math.sin(bAngle) * bLen + tipSway) + ',' + (ty - bLen),
            fill: 'none', stroke: rng() > 0.3 ? tc.base : tc.light, 'stroke-width': String(0.7 + rng() * 0.6), 'stroke-linecap': 'round', opacity: String(0.5 + rng() * 0.3)
          }));
        }
        if (rng() > 0.6) {
          const clusterColors = ['#e8d040', '#e06080', '#c080e0', '#6090e0'];
          const cc = clusterColors[Math.floor(rng() * clusterColors.length)];
          for (let fl = 0; fl < 3 + Math.floor(rng() * 3); fl++) {
            g.appendChild(svgEl('circle', { cx: String(tx + (rng() - 0.5) * 4), cy: String(ty - 3 - rng() * 5), r: String(0.8 + rng() * 1.0), fill: cc, opacity: String(0.6 + rng() * 0.3) }));
          }
        }
      }
      // Bushes
      const bushCount = 2 + Math.floor(rng() * 2);
      for (let b = 0; b < bushCount; b++) {
        const bx = (rng() - 0.5) * innerRx;
        const by = (rng() - 0.5) * innerRy * 0.8;
        const br = 2.5 + rng() * 2.5;
        g.appendChild(svgEl('circle', { cx: String(bx), cy: String(by), r: String(br), fill: tc.base, opacity: '0.5' }));
        g.appendChild(svgEl('circle', { cx: String(bx), cy: String(by), r: String(br), fill: 'none', stroke: tc.deep, 'stroke-width': '0.6', opacity: '0.4' }));
      }
      // Butterflies
      for (let bf = 0; bf < 1 + Math.floor(rng() * 2); bf++) {
        const bfx = (rng() - 0.5) * innerRx * 0.8;
        const bfy = (rng() - 0.5) * innerRy * 0.6 - 6;
        const bfc = ['#ff8844', '#ee55aa', '#44aaff', '#ffdd22'][Math.floor(rng() * 4)];
        const ws = 2 + rng() * 1.5;
        g.appendChild(svgEl('path', { d: 'M' + (bfx - ws) + ',' + (bfy - ws * 0.6) + ' L' + bfx + ',' + bfy + ' L' + (bfx + ws) + ',' + (bfy - ws * 0.6), fill: 'none', stroke: bfc, 'stroke-width': '0.8', 'stroke-linecap': 'round', opacity: '0.7' }));
      }
      break;
    }
    case 'snow': {
      const patchCount = Math.min(8, Math.max(3, Math.floor(rx / 8)));
      for (let i = 0; i < patchCount; i++) {
        const angle = rng() * Math.PI * 2;
        const dist = rng() * 0.7;
        g.appendChild(svgEl('ellipse', { cx: String(Math.cos(angle) * innerRx * dist), cy: String(Math.sin(angle) * innerRy * dist), rx: String(3 + rng() * 6), ry: String(2 + rng() * 3), fill: '#dce8ff', opacity: String(0.3 + rng() * 0.2) }));
      }
      // Ice crystals
      for (let i = 0; i < 4 + Math.floor(rng() * 4); i++) {
        const cx0 = (rng() - 0.5) * innerRx * 1.3;
        const cy0 = (rng() - 0.5) * innerRy;
        const cr = 1.5 + rng() * 2;
        for (let a = 0; a < 3; a++) {
          const ang = (a / 3) * Math.PI;
          g.appendChild(svgEl('line', { x1: String(cx0 + Math.cos(ang) * cr), y1: String(cy0 + Math.sin(ang) * cr), x2: String(cx0 - Math.cos(ang) * cr), y2: String(cy0 - Math.sin(ang) * cr), stroke: '#c0d8ff', 'stroke-width': '0.6', opacity: String(0.4 + rng() * 0.3), 'stroke-linecap': 'round' }));
        }
      }
      // Frost rocks with icicles
      for (let i = 0; i < 3 + Math.floor(rng() * 3); i++) {
        const rkx = (rng() - 0.5) * innerRx;
        const rky = (rng() - 0.5) * innerRy * 0.8;
        const rs = 2 + rng() * 3;
        const nv = 4 + Math.floor(rng() * 2);
        const pts = [];
        for (let v = 0; v < nv; v++) { const va = (v / nv) * Math.PI * 2; pts.push((rkx + Math.cos(va) * rs * (0.6 + rng() * 0.4)).toFixed(1) + ',' + (rky + Math.sin(va) * rs * 0.55 * (0.6 + rng() * 0.4)).toFixed(1)); }
        g.appendChild(svgEl('polygon', { points: pts.join(' '), fill: '#8090a0', opacity: '0.5' }));
        g.appendChild(svgEl('polyline', { points: pts.slice(0, Math.ceil(pts.length / 2)).join(' '), fill: 'none', stroke: '#e8f0ff', 'stroke-width': '0.8', opacity: '0.6', 'stroke-linecap': 'round' }));
        for (let ic = 0; ic < 2 + Math.floor(rng() * 2); ic++) {
          const icx = rkx + (rng() - 0.5) * rs * 1.2;
          g.appendChild(svgEl('line', { x1: String(icx), y1: String(rky + rs * 0.3), x2: String(icx), y2: String(rky + rs * 0.3 + 1.5 + rng() * 2.5), stroke: '#d0e4ff', 'stroke-width': '0.5', opacity: '0.5', 'stroke-linecap': 'round' }));
        }
      }
      // Bare trees
      for (let i = 0; i < 2 + Math.floor(rng() * 2); i++) {
        const btx = (rng() - 0.5) * innerRx * 0.9;
        const bty = (rng() - 0.5) * innerRy * 0.7;
        const bth = 6 + rng() * 6;
        g.appendChild(svgEl('line', { x1: String(btx), y1: String(bty), x2: String(btx), y2: String(bty - bth), stroke: '#5a4a40', 'stroke-width': '1.2', 'stroke-linecap': 'round', opacity: '0.6' }));
        for (let br = 0; br < 3 + Math.floor(rng() * 2); br++) {
          const brY = bty - bth * (0.4 + br * 0.18);
          const brDir = (br % 2 === 0) ? 1 : -1;
          const brLen = 2 + rng() * 4;
          g.appendChild(svgEl('line', { x1: String(btx), y1: String(brY), x2: String(btx + brDir * brLen), y2: String(brY - brLen * 0.5 + (rng() - 0.5) * brLen), stroke: '#5a4a40', 'stroke-width': '0.7', 'stroke-linecap': 'round', opacity: '0.5' }));
        }
      }
      break;
    }
    case 'desert': {
      // Sand ripples
      for (let i = 0; i < 3 + Math.floor(rng() * 3); i++) {
        const ry0 = (rng() - 0.5) * innerRy * 1.2;
        const rWidth = innerRx * (0.6 + rng() * 0.5);
        g.appendChild(svgEl('path', { d: 'M' + (-rWidth) + ',' + ry0 + ' Q0,' + (ry0 + (rng() - 0.5) * 4) + ' ' + rWidth + ',' + ry0, fill: 'none', stroke: tc.light, 'stroke-width': '1', opacity: '0.3' }));
      }
      // Cacti
      for (let i = 0; i < Math.min(4, Math.max(1, Math.floor(rx / 12))); i++) {
        if (rng() > 0.3) {
          const cx0 = (rng() - 0.5) * innerRx;
          const cy0 = (rng() - 0.5) * innerRy * 0.6;
          const ch = 6 + rng() * 8;
          const cw = 1.5;
          g.appendChild(svgEl('path', { d: 'M' + (cx0 - cw) + ',' + cy0 + ' L' + (cx0 - cw) + ',' + (cy0 - ch + cw) + ' Q' + (cx0 - cw) + ',' + (cy0 - ch) + ' ' + cx0 + ',' + (cy0 - ch) + ' Q' + (cx0 + cw) + ',' + (cy0 - ch) + ' ' + (cx0 + cw) + ',' + (cy0 - ch + cw) + ' L' + (cx0 + cw) + ',' + cy0 + ' Z', fill: '#4a7a30', opacity: '0.8' }));
          const armY1 = cy0 - ch * 0.5;
          g.appendChild(svgEl('path', { d: 'M' + (cx0 - cw) + ',' + armY1 + ' L' + (cx0 - cw - 3) + ',' + armY1 + ' L' + (cx0 - cw - 3) + ',' + (armY1 - 3 - rng() * 2), fill: 'none', stroke: '#4a7a30', 'stroke-width': String(cw * 1.5), 'stroke-linecap': 'round', opacity: '0.8' }));
          const armY2 = cy0 - ch * 0.65;
          g.appendChild(svgEl('path', { d: 'M' + (cx0 + cw) + ',' + armY2 + ' L' + (cx0 + cw + 3) + ',' + armY2 + ' L' + (cx0 + cw + 3) + ',' + (armY2 - 3 - rng() * 2), fill: 'none', stroke: '#4a7a30', 'stroke-width': String(cw * 1.5), 'stroke-linecap': 'round', opacity: '0.8' }));
        }
      }
      // Tumbleweeds
      for (let i = 0; i < 1 + Math.floor(rng() * 2); i++) {
        const twx = (rng() - 0.5) * innerRx * 0.9;
        const twy = (rng() - 0.5) * innerRy * 0.7;
        const twr = 2 + rng() * 2;
        g.appendChild(svgEl('circle', { cx: String(twx), cy: String(twy), r: String(twr), fill: 'none', stroke: '#8a6a30', 'stroke-width': '0.6', opacity: '0.5' }));
        for (let s = 0; s < 3; s++) { const sa = rng() * Math.PI * 2; g.appendChild(svgEl('line', { x1: String(twx + Math.cos(sa) * twr * 0.7), y1: String(twy + Math.sin(sa) * twr * 0.7), x2: String(twx + Math.cos(sa + 2) * twr * 0.8), y2: String(twy + Math.sin(sa + 2) * twr * 0.8), stroke: '#8a6a30', 'stroke-width': '0.4', opacity: '0.4' })); }
      }
      // Skull
      { const skx = (rng() - 0.5) * innerRx * 0.6; const sky = (rng() - 0.5) * innerRy * 0.5;
        g.appendChild(svgEl('ellipse', { cx: String(skx), cy: String(sky), rx: '1.8', ry: '1.4', fill: '#f0ece0', opacity: '0.5' }));
        g.appendChild(svgEl('circle', {cx: String(skx - 0.6), cy: String(sky - 0.2), r: '0.3', fill: '#666', opacity: '0.4'}));
        g.appendChild(svgEl('circle', {cx: String(skx + 0.6), cy: String(sky - 0.2), r: '0.3', fill: '#666', opacity: '0.4'})); }
      // Heat shimmer
      { const shY = (rng() - 0.5) * innerRy * 0.4 - ry * 0.15; const shW = innerRx * 0.7;
        g.appendChild(svgEl('path', { d: 'M' + (-shW) + ',' + shY + ' C' + (-shW * 0.5) + ',' + (shY - 2) + ' ' + (-shW * 0.2) + ',' + (shY + 2) + ' 0,' + shY + ' C' + (shW * 0.2) + ',' + (shY - 2) + ' ' + (shW * 0.5) + ',' + (shY + 2) + ' ' + shW + ',' + shY, fill: 'none', stroke: 'rgba(255,240,200,0.2)', 'stroke-width': '1.5', 'stroke-linecap': 'round' })); }
      break;
    }
    case 'volcanic': {
      // Charred rocks
      for (let i = 0; i < 3 + Math.floor(rng() * 3); i++) {
        const rkx = (rng() - 0.5) * innerRx; const rky = (rng() - 0.5) * innerRy * 0.8;
        const rs = 2 + rng() * 4; const nv = 4 + Math.floor(rng() * 3);
        const pts = []; for (let v = 0; v < nv; v++) { const va = (v / nv) * Math.PI * 2; const vr = rs * (0.5 + rng() * 0.5); pts.push((rkx + Math.cos(va) * vr).toFixed(1) + ',' + (rky + Math.sin(va) * vr * 0.6).toFixed(1)); }
        g.appendChild(svgEl('polygon', { points: pts.join(' '), fill: '#2a2020', opacity: '0.6' }));
        g.appendChild(svgEl('polygon', { points: pts.join(' '), fill: 'none', stroke: '#8a3020', 'stroke-width': '0.6', opacity: '0.4' }));
      }
      // Lava glow (3 concentric ellipses)
      const glowR = rx * 0.35; const glowY = -ry * 0.1;
      g.appendChild(svgEl('ellipse', { cx: '0', cy: String(glowY), rx: String(glowR * 1.2), ry: String(glowR * 0.8), fill: 'rgba(255,60,10,0.08)' }));
      g.appendChild(svgEl('ellipse', { cx: '0', cy: String(glowY), rx: String(glowR * 0.7), ry: String(glowR * 0.5), fill: 'rgba(255,80,20,0.15)' }));
      g.appendChild(svgEl('ellipse', { cx: '0', cy: String(glowY), rx: String(glowR * 0.35), ry: String(glowR * 0.25), fill: 'rgba(255,140,40,0.25)' }));
      // Lava cracks (branching)
      for (let i = 0; i < 5; i++) {
        const sx = (rng() - 0.5) * innerRx * 0.8; const sy = (rng() - 0.5) * innerRy * 0.6;
        const len = 6 + rng() * 10; const ang = rng() * Math.PI * 2;
        const ex = sx + Math.cos(ang) * len; const ey = sy + Math.sin(ang) * len * 0.6;
        const mx = (sx + ex) / 2 + (rng() - 0.5) * 4; const my = (sy + ey) / 2 + (rng() - 0.5) * 3;
        g.appendChild(svgEl('path', { d: 'M' + sx.toFixed(1) + ',' + sy.toFixed(1) + ' Q' + mx.toFixed(1) + ',' + my.toFixed(1) + ' ' + ex.toFixed(1) + ',' + ey.toFixed(1), fill: 'none', stroke: '#ff5020', 'stroke-width': '1.5', opacity: '0.5', 'stroke-linecap': 'round' }));
        if (rng() > 0.4) g.appendChild(svgEl('line', { x1: mx.toFixed(1), y1: my.toFixed(1), x2: (mx + (rng() - 0.5) * 5).toFixed(1), y2: (my + (rng() - 0.5) * 4).toFixed(1), stroke: '#ff6030', 'stroke-width': '0.8', opacity: '0.4', 'stroke-linecap': 'round' }));
      }
      // Smoke plumes
      const smokeX = (rng() - 0.5) * innerRx * 0.3; const smokeBaseY = -ry * 0.25;
      for (let i = 0; i < 4 + Math.floor(rng() * 3); i++) {
        const sr = (3.5 - i * 0.45) + rng() * 1.5;
        g.appendChild(svgEl('circle', { cx: String(smokeX + (rng() - 0.5) * i * 1.5), cy: String(smokeBaseY - i * 4.5 - rng() * 2), r: String(Math.max(0.5, sr)), fill: 'rgba(100,100,100,' + Math.max(0.02, 0.18 - i * 0.025).toFixed(3) + ')' }));
      }
      // Embers
      for (let i = 0; i < 3 + Math.floor(rng() * 3); i++) {
        g.appendChild(svgEl('circle', { cx: String((rng() - 0.5) * innerRx * 0.6), cy: String(-ry * 0.2 - rng() * ry * 0.35), r: String(0.5 + rng() * 0.8), fill: '#ff8820', opacity: String(0.4 + rng() * 0.4) }));
      }
      break;
    }
    case 'rocky': {
      // Layered cliff faces
      for (let l = 0; l < 3 + Math.floor(rng() * 2); l++) {
        const lFrac = l / (3 + Math.floor(rng()));
        const lx = (rng() - 0.5) * innerRx * 0.8;
        const ly = -innerRy * 0.3 + lFrac * innerRy * 0.7;
        const lw = innerRx * (0.4 + rng() * 0.4);
        const lh = 3 + rng() * 5;
        const jag1 = (rng() - 0.5) * 3; const jag2 = (rng() - 0.5) * 3;
        g.appendChild(svgEl('path', { d: 'M' + (lx - lw * 0.5) + ',' + (ly + lh) + ' L' + (lx - lw * 0.45 + jag1) + ',' + ly + ' L' + (lx - lw * 0.1 + jag2) + ',' + (ly - 1 - rng() * 2) + ' L' + (lx + lw * 0.2) + ',' + (ly + rng()) + ' L' + (lx + lw * 0.5) + ',' + (ly + lh) + ' Z', fill: rng() > 0.5 ? tc.light : tc.deep, opacity: String(0.4 + rng() * 0.15) }));
        g.appendChild(svgEl('path', { d: 'M' + (lx - lw * 0.45 + jag1) + ',' + ly + ' L' + (lx - lw * 0.1 + jag2) + ',' + (ly - 1 - rng() * 2) + ' L' + (lx + lw * 0.2) + ',' + (ly + rng()), fill: 'none', stroke: tc.light, 'stroke-width': '0.8', opacity: '0.5', 'stroke-linecap': 'round' }));
      }
      // Fissures
      for (let i = 0; i < 3 + Math.floor(rng() * 3); i++) {
        const fx = (rng() - 0.5) * innerRx * 0.9; const fy = (rng() - 0.5) * innerRy * 0.8;
        const fLen = 3 + rng() * 6;
        g.appendChild(svgEl('line', { x1: String(fx), y1: String(fy), x2: String(fx + fLen), y2: String(fy + (-0.3 + rng() * 0.6) * fLen), stroke: '#2a2820', 'stroke-width': '0.5', opacity: '0.35', 'stroke-linecap': 'round' }));
      }
      // Lichen
      for (let i = 0; i < 5 + Math.floor(rng() * 5); i++) {
        g.appendChild(svgEl('circle', { cx: String((rng() - 0.5) * innerRx), cy: String((rng() - 0.5) * innerRy * 0.9), r: String(0.5 + rng() * 1.2), fill: '#a0b848', opacity: String(0.3 + rng() * 0.25) }));
      }
      // Hardy grass
      for (let i = 0; i < 2 + Math.floor(rng() * 2); i++) {
        const gx = (rng() - 0.5) * innerRx * 0.8; const gy = (rng() - 0.5) * innerRy * 0.7;
        for (let b = 0; b < 3; b++) { const bAng = (b - 1) * 0.4 + (rng() - 0.5) * 0.3; g.appendChild(svgEl('line', { x1: String(gx), y1: String(gy), x2: String(gx + Math.sin(bAng) * (2 + rng() * 3)), y2: String(gy - 2 - rng() * 3), stroke: '#5a8838', 'stroke-width': '0.7', 'stroke-linecap': 'round', opacity: '0.5' })); }
      }
      break;
    }
    case 'marsh': {
      // Standing water pools
      for (let i = 0; i < 3 + Math.floor(rng() * 3); i++) {
        const px = (rng() - 0.5) * innerRx; const py = (rng() - 0.5) * innerRy;
        const prx = 3 + rng() * 5; const pry = 2 + rng() * 3;
        g.appendChild(svgEl('ellipse', { cx: String(px), cy: String(py), rx: String(prx), ry: String(pry), fill: 'rgba(40,100,120,0.3)', stroke: 'rgba(60,130,150,0.2)', 'stroke-width': '0.5' }));
        g.appendChild(svgEl('ellipse', { cx: String(px - prx * 0.2), cy: String(py - pry * 0.25), rx: String(prx * 0.4), ry: String(pry * 0.3), fill: 'rgba(180,220,240,0.15)' }));
      }
      // Moss patches
      for (let i = 0; i < 4 + Math.floor(rng() * 4); i++) {
        g.appendChild(svgEl('ellipse', { cx: String((rng() - 0.5) * innerRx * 1.1), cy: String((rng() - 0.5) * innerRy * 0.9), rx: String(1.5 + rng() * 2.5), ry: String(1 + rng() * 1.5), fill: '#4a7a38', opacity: String(0.25 + rng() * 0.2) }));
      }
      // Lily pads with notch
      for (let i = 0; i < 3 + Math.floor(rng() * 4); i++) {
        const lx = (rng() - 0.5) * innerRx * 0.9; const ly = (rng() - 0.5) * innerRy * 0.8;
        const lr = 2.5 + rng() * 3;
        const na = rng() * Math.PI * 2;
        g.appendChild(svgEl('path', { d: 'M' + lx + ',' + ly + ' L' + (lx + Math.cos(na + 0.25) * lr) + ',' + (ly + Math.sin(na + 0.25) * lr * 0.6) + ' A' + lr + ',' + (lr * 0.6) + ' 0 1,1 ' + (lx + Math.cos(na - 0.25) * lr) + ',' + (ly + Math.sin(na - 0.25) * lr * 0.6) + ' Z', fill: '#4a8a38', opacity: String(0.5 + rng() * 0.2) }));
      }
      // Reeds and cattails
      for (let i = 0; i < Math.min(10, Math.max(4, Math.floor(rx / 7))); i++) {
        const angle = rng() * Math.PI * 2; const dist = rng() * 0.7;
        const tx = Math.cos(angle) * innerRx * dist; const ty = Math.sin(angle) * innerRy * dist;
        const h = 5 + rng() * 8; const curv = (rng() - 0.5) * 4;
        const topX = tx + curv; const topY = ty - h;
        if (Math.abs(curv) > 1) g.appendChild(svgEl('path', { d: 'M' + tx + ',' + ty + ' Q' + (tx + curv * 0.5) + ',' + (ty - h * 0.5) + ' ' + topX + ',' + topY, fill: 'none', stroke: '#6a8a40', 'stroke-width': '1', 'stroke-linecap': 'round', opacity: '0.7' }));
        else g.appendChild(svgEl('line', { x1: String(tx), y1: String(ty), x2: String(topX), y2: String(topY), stroke: '#6a8a40', 'stroke-width': '1', 'stroke-linecap': 'round', opacity: '0.7' }));
        if (rng() > 0.4) {
          g.appendChild(svgEl('ellipse', { cx: String(topX), cy: String(topY - 1.5), rx: '1.3', ry: '3', fill: '#5a4020', opacity: '0.7' }));
          g.appendChild(svgEl('line', { x1: String(topX), y1: String(topY - 4.5), x2: String(topX), y2: String(topY - 6), stroke: '#6a8a40', 'stroke-width': '0.4', 'stroke-linecap': 'round', opacity: '0.5' }));
        }
      }
      // Dragonfly
      { const dfx = (rng() - 0.5) * innerRx * 0.6; const dfy = (rng() - 0.5) * innerRy * 0.5 - 5;
        const dfLen = 4 + rng() * 2; const dfAng = (rng() - 0.5) * 0.4;
        g.appendChild(svgEl('line', { x1: String(dfx), y1: String(dfy), x2: String(dfx + Math.cos(dfAng) * dfLen), y2: String(dfy + Math.sin(dfAng) * dfLen), stroke: '#3060a0', 'stroke-width': '0.8', 'stroke-linecap': 'round', opacity: '0.6' }));
        const wmx = dfx + Math.cos(dfAng) * dfLen * 0.35; const wmy = dfy + Math.sin(dfAng) * dfLen * 0.35;
        const wl = 2 + rng(); const px = -Math.sin(dfAng); const py = Math.cos(dfAng);
        g.appendChild(svgEl('line', { x1: String(wmx), y1: String(wmy), x2: String(wmx + px * wl), y2: String(wmy + py * wl), stroke: 'rgba(100,160,220,0.5)', 'stroke-width': '0.5', 'stroke-linecap': 'round' }));
        g.appendChild(svgEl('line', { x1: String(wmx), y1: String(wmy), x2: String(wmx - px * wl), y2: String(wmy - py * wl), stroke: 'rgba(100,160,220,0.5)', 'stroke-width': '0.5', 'stroke-linecap': 'round' }));
      }
      break;
    }
  }
}

// ========== DRAW MOUNTAINS ==========
function drawMountains(g, isl, tc, rng) {
  const { rx, ry, docs } = isl;
  const numPeaks = Math.min(5, Math.max(1, Math.floor(docs / 60)));
  const baseHeight = Math.sqrt(docs) * 3;

  // Pre-compute all peaks for back-to-front sorting
  const peaks = [];
  for (let p = 0; p < numPeaks; p++) {
    const peakFrac = (p + 0.5) / numPeaks;
    const px = (peakFrac - 0.5) * rx * 1.2;
    const py = -ry * 0.15 - rng() * ry * 0.15;
    const h = baseHeight * (0.6 + rng() * 0.5);
    const w = rx * 0.25 + rng() * rx * 0.15;
    const peakX = px + (rng() - 0.5) * w * 0.3;
    const peakY = py - h;
    const baseY = py + h * 0.15;
    peaks.push({ px, py, h, w, peakX, peakY, baseY, baseLeft: px - w, baseRight: px + w });
  }
  peaks.sort((a, b) => a.baseY - b.baseY);

  // Background ridgelines (depth silhouettes)
  const numRidges = 1 + Math.floor(rng() * 1.5);
  for (let r = 0; r < numRidges; r++) {
    const ridgeY = -ry * 0.08 - rng() * ry * 0.12;
    const ridgeH = baseHeight * 0.6 * (0.7 + rng() * 0.4);
    const ridgeW = rx * 0.9 + rng() * rx * 0.3;
    const ridgeCx = (rng() - 0.5) * rx * 0.3;
    const ridgeBaseY = ridgeY + ridgeH * 0.1;
    const subPeaks = 3 + Math.floor(rng() * 3);
    let ridgePath = 'M' + (ridgeCx - ridgeW).toFixed(1) + ',' + ridgeBaseY.toFixed(1);
    for (let s = 0; s < subPeaks; s++) {
      const frac = (s + 0.5) / subPeaks;
      const sx = ridgeCx - ridgeW + frac * ridgeW * 2;
      const sh = ridgeH * (0.4 + rng() * 0.6);
      ridgePath += ' C' + (sx - ridgeW / subPeaks * 0.3).toFixed(1) + ',' + (ridgeBaseY - sh * 0.6).toFixed(1) +
        ' ' + (sx - ridgeW / subPeaks * 0.1).toFixed(1) + ',' + (ridgeBaseY - sh).toFixed(1) +
        ' ' + sx.toFixed(1) + ',' + (ridgeBaseY - sh).toFixed(1);
      ridgePath += ' C' + (sx + ridgeW / subPeaks * 0.1).toFixed(1) + ',' + (ridgeBaseY - sh).toFixed(1) +
        ' ' + (sx + ridgeW / subPeaks * 0.3).toFixed(1) + ',' + (ridgeBaseY - sh * 0.6).toFixed(1) +
        ' ' + (sx + ridgeW / subPeaks * 0.4).toFixed(1) + ',' + ridgeBaseY.toFixed(1);
    }
    ridgePath += ' L' + (ridgeCx + ridgeW).toFixed(1) + ',' + ridgeBaseY.toFixed(1) + ' Z';
    g.appendChild(svgEl('path', { d: ridgePath, fill: tc.deep, opacity: String(0.25 - r * 0.08) }));
  }

  // Main peaks (back-to-front)
  for (let i = 0; i < peaks.length; i++) {
    const pk = peaks[i];
    const { h, w, peakX, peakY, baseY, baseLeft, baseRight } = pk;
    const depthFade = i < peaks.length / 2 ? 0.15 : 0;

    // Base shadow
    g.appendChild(svgEl('ellipse', {
      cx: ((baseLeft + baseRight) / 2).toFixed(1), cy: (baseY + 2).toFixed(1),
      rx: (w * 1.5).toFixed(1), ry: '4', fill: 'rgba(0,0,0,0.2)'
    }));

    // Dark face
    const darkPath = 'M' + peakX.toFixed(1) + ',' + peakY.toFixed(1) +
      ' C' + (peakX + w * 0.15).toFixed(1) + ',' + (peakY + h * 0.1).toFixed(1) +
      ' ' + ((peakX + baseRight) / 2).toFixed(1) + ',' + (baseY - h * 0.2).toFixed(1) +
      ' ' + baseRight.toFixed(1) + ',' + baseY.toFixed(1) +
      ' L' + peakX.toFixed(1) + ',' + baseY.toFixed(1) + ' Z';
    g.appendChild(svgEl('path', { d: darkPath, fill: tc.deep, opacity: String(0.85 - depthFade) }));

    // Rock texture (scree on dark face)
    const numScree = 8 + Math.floor(rng() * 8);
    for (let s = 0; s < numScree; s++) {
      const t = 0.2 + rng() * 0.7;
      const yPos = peakY + t * (baseY - peakY);
      const xRight = peakX + (baseRight - peakX) * t;
      const xStart = peakX + (xRight - peakX) * (0.1 + rng() * 0.8);
      const lineLen = 2 + rng() * 5;
      const ang = -0.5 + rng() * 1.0;
      g.appendChild(svgEl('line', {
        x1: xStart.toFixed(1), y1: yPos.toFixed(1),
        x2: (xStart + lineLen * Math.cos(ang)).toFixed(1), y2: (yPos + lineLen * Math.sin(ang)).toFixed(1),
        stroke: rng() > 0.5 ? '#5a5040' : '#6a6050',
        'stroke-width': (0.5 + rng() * 0.5).toFixed(2), opacity: (0.2 + rng() * 0.2).toFixed(2)
      }));
    }

    // Light face
    const lightPath = 'M' + baseLeft.toFixed(1) + ',' + baseY.toFixed(1) +
      ' C' + ((baseLeft + peakX) / 2).toFixed(1) + ',' + (baseY - h * 0.3).toFixed(1) +
      ' ' + (peakX - w * 0.15).toFixed(1) + ',' + (peakY + h * 0.1).toFixed(1) +
      ' ' + peakX.toFixed(1) + ',' + peakY.toFixed(1) +
      ' L' + peakX.toFixed(1) + ',' + baseY.toFixed(1) + ' Z';
    g.appendChild(svgEl('path', { d: lightPath, fill: tc.base, opacity: String(0.9 - depthFade) }));

    // Rim lighting (sun-facing left edge)
    g.appendChild(svgEl('path', {
      d: 'M' + baseLeft.toFixed(1) + ',' + baseY.toFixed(1) +
        ' C' + ((baseLeft + peakX) / 2).toFixed(1) + ',' + (baseY - h * 0.3).toFixed(1) +
        ' ' + (peakX - w * 0.15).toFixed(1) + ',' + (peakY + h * 0.1).toFixed(1) +
        ' ' + peakX.toFixed(1) + ',' + peakY.toFixed(1),
      fill: 'none', stroke: tc.light, 'stroke-width': '1.5', opacity: (0.6 - depthFade).toFixed(2)
    }));
    g.appendChild(svgEl('path', {
      d: 'M' + baseLeft.toFixed(1) + ',' + baseY.toFixed(1) +
        ' C' + ((baseLeft + peakX) / 2).toFixed(1) + ',' + (baseY - h * 0.3).toFixed(1) +
        ' ' + (peakX - w * 0.15).toFixed(1) + ',' + (peakY + h * 0.1).toFixed(1) +
        ' ' + peakX.toFixed(1) + ',' + peakY.toFixed(1),
      fill: 'none', stroke: '#fff', 'stroke-width': '0.6', opacity: (0.25 - depthFade).toFixed(2)
    }));

    // Snow cap (wavy bottom edge + blue shadow)
    if (h > 20) {
      const snowFrac = 0.25;
      const snowY = peakY + h * snowFrac;
      const snowLeftX = peakX - w * snowFrac * 0.7;
      const snowRightX = peakX + w * snowFrac * 0.6;
      const midX = (snowLeftX + snowRightX) / 2;
      const wave1X = snowLeftX + (midX - snowLeftX) * 0.5;
      const wave2X = midX + (snowRightX - midX) * 0.5;
      const waveDip1 = 2 + rng() * 2;
      const waveDip2 = 1.5 + rng() * 2;

      // Blue shadow under snow
      g.appendChild(svgEl('path', {
        d: 'M' + snowLeftX.toFixed(1) + ',' + (snowY + 1).toFixed(1) +
          ' Q' + wave1X.toFixed(1) + ',' + (snowY + waveDip1 + 1.5).toFixed(1) + ' ' + midX.toFixed(1) + ',' + (snowY + 1).toFixed(1) +
          ' Q' + wave2X.toFixed(1) + ',' + (snowY + waveDip2 + 1.5).toFixed(1) + ' ' + snowRightX.toFixed(1) + ',' + (snowY + 1).toFixed(1),
        fill: 'none', stroke: 'rgba(80,100,160,0.35)', 'stroke-width': '1.5'
      }));
      // Snow body
      g.appendChild(svgEl('path', {
        d: 'M' + peakX.toFixed(1) + ',' + peakY.toFixed(1) +
          ' C' + (peakX - w * 0.08).toFixed(1) + ',' + (peakY + h * 0.05).toFixed(1) + ' ' + snowLeftX.toFixed(1) + ',' + (snowY - 2).toFixed(1) + ' ' + snowLeftX.toFixed(1) + ',' + snowY.toFixed(1) +
          ' Q' + wave1X.toFixed(1) + ',' + (snowY + waveDip1).toFixed(1) + ' ' + midX.toFixed(1) + ',' + (snowY - 0.5).toFixed(1) +
          ' Q' + wave2X.toFixed(1) + ',' + (snowY + waveDip2).toFixed(1) + ' ' + snowRightX.toFixed(1) + ',' + snowY.toFixed(1) +
          ' C' + snowRightX.toFixed(1) + ',' + (snowY - 2).toFixed(1) + ' ' + (peakX + w * 0.08).toFixed(1) + ',' + (peakY + h * 0.05).toFixed(1) + ' ' + peakX.toFixed(1) + ',' + peakY.toFixed(1) + ' Z',
        fill: '#e8eef8', opacity: (0.85 - depthFade).toFixed(2), stroke: 'rgba(200,210,230,0.3)', 'stroke-width': '0.5'
      }));
    }

    // Cloud wisps on tall peaks
    if (h > 30) {
      const numClouds = 2 + Math.floor(rng() * 2);
      for (let c = 0; c < numClouds; c++) {
        const cloudY = peakY + h * (1 - (0.6 + rng() * 0.15));
        const cloudX = peakX + (rng() - 0.4) * w * 1.2;
        g.appendChild(svgEl('ellipse', {
          cx: cloudX.toFixed(1), cy: cloudY.toFixed(1),
          rx: (8 + rng() * 7).toFixed(1), ry: (3 + rng() * 3).toFixed(1),
          fill: '#fff', opacity: (0.15 + rng() * 0.10).toFixed(2)
        }));
      }
    }

    // Tree line at base
    const numTreeline = 3 + Math.floor(rng() * 4);
    for (let t = 0; t < numTreeline; t++) {
      const treeFrac = (t + 0.5) / numTreeline;
      const treeX = baseLeft + treeFrac * (baseRight - baseLeft);
      const treeH = 3 + rng() * 2;
      const treeW = treeH * 0.6;
      g.appendChild(svgEl('path', {
        d: 'M' + treeX.toFixed(1) + ',' + (baseY - treeH).toFixed(1) + ' L' + (treeX - treeW / 2).toFixed(1) + ',' + baseY.toFixed(1) + ' L' + (treeX + treeW / 2).toFixed(1) + ',' + baseY.toFixed(1) + ' Z',
        fill: rng() > 0.5 ? '#2a6a3a' : '#3a7a4a', opacity: (0.6 + rng() * 0.3).toFixed(2)
      }));
    }
  }
}

// ========== DRAW SINGLE ISLAND ==========
function drawIsland(parentG, isl, idx) {
  const tc = TERRAIN[isl.terrain];
  const { rx, ry } = isl;
  const rng = lcg(idx * 7919 + 1337);
  const seed = idx * 7919 + 1337;

  const g = svgEl('g', {
    transform: 'translate(' + isl.x + ',' + isl.y + ')',
    class: 'island-group',
    'data-id': isl.id,
    cursor: 'pointer'
  });

  const isHub = isl.type === 'hub';

  // === Layer 1: Water shadow (dark ellipse below) ===
  g.appendChild(svgEl('path', {
    d: blobPath(4, 10, rx + 20, ry + 14, seed + 100, 14),
    fill: 'rgba(0,10,30,0.3)',
    filter: 'url(#islandShadow)'
  }));

  // === Layer 2: Shallow water glow ===
  g.appendChild(svgEl('path', {
    d: blobPath(0, 0, rx + 22, ry + 16, seed + 200, 16),
    fill: tc.water,
    opacity: '0.2'
  }));

  // === Layer 3: Foam/surf line ===
  g.appendChild(svgEl('path', {
    d: blobPath(0, 0, rx + 14, ry + 10, seed + 300, 14),
    fill: 'none',
    stroke: 'rgba(255,255,255,0.25)',
    'stroke-width': '2',
    'stroke-dasharray': '4 3'
  }));

  // === Layer 3a: Rocky shoreline (jagged irregular edge) ===
  const shoreRng = lcg(seed + 350);
  g.appendChild(svgEl('path', {
    d: blobPath(0, 0, rx + 9, ry + 7, seed + 350, 18),
    fill: tc.deep, opacity: '0.18'
  }));

  // === Layer 3b: Shore rocks ===
  const numRocks = Math.floor(4 + shoreRng() * 5);
  for (let r = 0; r < numRocks; r++) {
    const rAngle = shoreRng() * Math.PI * 2;
    const rDist = rx + 4 + shoreRng() * 6;
    const rDistY = (ry + 4 + shoreRng() * 6) * 0.65;
    const rcx = Math.cos(rAngle) * rDist;
    const rcy = Math.sin(rAngle) * rDistY;
    const rockVerts = 4 + Math.floor(shoreRng() * 3);
    const rockR = 2 + shoreRng() * 3;
    let rockD = '';
    for (let v = 0; v < rockVerts; v++) {
      const va = (v / rockVerts) * Math.PI * 2;
      const vr = rockR * (0.6 + shoreRng() * 0.8);
      rockD += (v === 0 ? 'M' : 'L') + (rcx + Math.cos(va) * vr).toFixed(1) + ',' + (rcy + Math.sin(va) * vr).toFixed(1);
    }
    g.appendChild(svgEl('path', { d: rockD + 'Z', fill: tc.deep, opacity: (0.4 + shoreRng() * 0.2).toFixed(2) }));
  }

  // === Layer 3c: Tidal pools (medium+ islands) ===
  if (rx > 50) {
    const numPools = 2 + Math.floor(shoreRng() * 3);
    for (let p = 0; p < numPools; p++) {
      const poolAngle = shoreRng() * Math.PI * 2;
      const poolDist = rx * (0.85 + shoreRng() * 0.15);
      const poolDistY = ry * (0.85 + shoreRng() * 0.15) * 0.65;
      g.appendChild(svgEl('ellipse', {
        cx: (Math.cos(poolAngle) * poolDist).toFixed(1), cy: (Math.sin(poolAngle) * poolDistY).toFixed(1),
        rx: (3 + shoreRng() * 4).toFixed(1), ry: (2 + shoreRng() * 3).toFixed(1),
        fill: tc.water, opacity: '0.35'
      }));
    }
  }

  // === Layer 3d: Wave-break arcs (windward side) ===
  const numArcs = 3 + Math.floor(shoreRng() * 3);
  for (let a = 0; a < numArcs; a++) {
    const arcCenter = Math.PI * 0.67 + shoreRng() * Math.PI * 0.83;
    const arcSpan = (30 + shoreRng() * 20) * (Math.PI / 180);
    const arcDist = rx + 16 + shoreRng() * 4;
    const arcDistY = (ry + 16 + shoreRng() * 4) * 0.65;
    const ax1 = Math.cos(arcCenter - arcSpan / 2) * arcDist;
    const ay1 = Math.sin(arcCenter - arcSpan / 2) * arcDistY;
    const ax2 = Math.cos(arcCenter + arcSpan / 2) * arcDist;
    const ay2 = Math.sin(arcCenter + arcSpan / 2) * arcDistY;
    g.appendChild(svgEl('path', {
      d: 'M' + ax1.toFixed(1) + ',' + ay1.toFixed(1) + ' A' + arcDist.toFixed(1) + ',' + arcDistY.toFixed(1) + ' 0 0,1 ' + ax2.toFixed(1) + ',' + ay2.toFixed(1),
      fill: 'none', stroke: 'rgba(255,255,255,' + (0.15 + shoreRng() * 0.10).toFixed(2) + ')',
      'stroke-width': (1 + shoreRng() * 0.5).toFixed(1), 'stroke-dasharray': '3 2', 'stroke-linecap': 'round'
    }));
  }

  // === Layer 4: Beach ring ===
  g.appendChild(svgEl('path', {
    d: blobPath(0, 0, rx + 6, ry + 5, seed + 400, 12),
    fill: tc.beach,
    opacity: '0.75'
  }));

  // === Layer 5: Main island body with gradient ===
  const mainPath = blobPath(0, 0, rx, ry, seed, 12);
  // Clip path for this island
  const clipId = 'clip-' + isl.id;
  const clip = svgEl('clipPath', {id: clipId});
  clip.appendChild(svgEl('path', {d: mainPath}));
  g.appendChild(clip);

  g.appendChild(svgEl('path', {
    d: mainPath,
    fill: 'url(#islandGrad-' + isl.terrain + ')',
    stroke: tc.deep,
    'stroke-width': '1',
    opacity: '0.95'
  }));

  // === Layer 6: Terrain highlight (upper-left) ===
  g.appendChild(svgEl('path', {
    d: blobPath(-rx * 0.15, -ry * 0.2, rx * 0.7, ry * 0.6, seed + 500, 10),
    fill: tc.light,
    opacity: '0.25',
    'clip-path': 'url(#' + clipId + ')'
  }));

  // === Layer 7: Vegetation ===
  const vegG = svgEl('g', {'clip-path': 'url(#' + clipId + ')'});
  const vegRng = lcg(seed + 600);
  drawVegetation(vegG, isl, tc, vegRng);
  g.appendChild(vegG);

  // === Layer 8: Mountains ===
  const mtG = svgEl('g', {'clip-path': 'url(#' + clipId + ')'});
  const mtRng = lcg(seed + 700);
  drawMountains(mtG, isl, tc, mtRng);
  g.appendChild(mtG);

  // === Layer 8b: Library buildings ===
  const libRng = lcg(seed + 750);
  const numLibs = isl.libs.length;
  const libScale = isHub ? 1.2 : 0.85;
  const libSpread = rx * 0.55; // horizontal spread
  const libBaseY = ry * 0.12; // vertical center for buildings (lower half)
  isl.libs.forEach((lib, li) => {
    // Position: evenly distributed horizontally, slight random offset
    const libFrac = numLibs === 1 ? 0 : (li / (numLibs - 1)) - 0.5; // -0.5 to 0.5
    const bx = libFrac * libSpread * 1.6 + (libRng() - 0.5) * 6;
    const by = libBaseY + (libRng() - 0.5) * ry * 0.25;

    const bW = (10 + Math.min(lib.c, 100) * 0.06) * libScale; // wider for more docs
    const bH = (10 + Math.min(lib.c, 100) * 0.08) * libScale; // taller for more docs
    const roofH = bH * 0.45;

    const bldgG = svgEl('g', {
      transform: 'translate(' + bx.toFixed(1) + ',' + by.toFixed(1) + ')'
    });
    // Tooltip with library name and doc count
    bldgG.appendChild(svgEl('title', {}, lib.n + ' (' + lib.c + ' dok)'));

    // Building shadow
    bldgG.appendChild(svgEl('rect', {
      x: String((-bW / 2 + 1).toFixed(1)), y: String((-bH + 2).toFixed(1)),
      width: String(bW.toFixed(1)), height: String(bH.toFixed(1)),
      rx: '1', fill: 'rgba(0,0,0,0.2)'
    }));

    // Building body
    const wallColor = isHub ? '#c8a850' : '#b8a878';
    const wallDark = isHub ? '#8a7030' : '#7a6a50';
    bldgG.appendChild(svgEl('rect', {
      x: String((-bW / 2).toFixed(1)), y: String((-bH).toFixed(1)),
      width: String(bW.toFixed(1)), height: String(bH.toFixed(1)),
      rx: '1', fill: wallColor, stroke: wallDark, 'stroke-width': '0.5'
    }));

    // Window / door detail (small dark rect)
    const doorW = bW * 0.25;
    const doorH = bH * 0.35;
    bldgG.appendChild(svgEl('rect', {
      x: String((-doorW / 2).toFixed(1)), y: String((-doorH - 1).toFixed(1)),
      width: String(doorW.toFixed(1)), height: String(doorH.toFixed(1)),
      rx: '0.5', fill: wallDark, opacity: '0.5'
    }));

    // Windows (one on each side of door for wider buildings)
    if (bW > 10) {
      const winS = 2 * libScale;
      bldgG.appendChild(svgEl('rect', {
        x: String((-bW / 2 + 2).toFixed(1)), y: String((-bH + 3).toFixed(1)),
        width: String(winS.toFixed(1)), height: String(winS.toFixed(1)),
        fill: '#5a8aa8', stroke: wallDark, 'stroke-width': '0.3', opacity: '0.8'
      }));
      bldgG.appendChild(svgEl('rect', {
        x: String((bW / 2 - 2 - winS).toFixed(1)), y: String((-bH + 3).toFixed(1)),
        width: String(winS.toFixed(1)), height: String(winS.toFixed(1)),
        fill: '#5a8aa8', stroke: wallDark, 'stroke-width': '0.3', opacity: '0.8'
      }));
    }

    // Roof (triangle)
    const roofColor = isHub ? '#6a4a28' : '#5a5048';
    const roofLeft = -bW / 2 - 2;
    const roofRight = bW / 2 + 2;
    const roofTop = -bH - roofH;
    bldgG.appendChild(svgEl('path', {
      d: 'M' + roofLeft.toFixed(1) + ',' + (-bH).toFixed(1) +
         ' L0,' + roofTop.toFixed(1) +
         ' L' + roofRight.toFixed(1) + ',' + (-bH).toFixed(1) + ' Z',
      fill: roofColor, stroke: wallDark, 'stroke-width': '0.4'
    }));

    // Library name initial on roof peak
    bldgG.appendChild(svgEl('text', {
      x: '0', y: String((roofTop + roofH * 0.45).toFixed(1)),
      'text-anchor': 'middle', 'dominant-baseline': 'central',
      fill: '#fff', 'font-size': String((4 * libScale).toFixed(1)),
      'font-weight': '700', opacity: '0.7',
      'font-family': "'Segoe UI',system-ui,sans-serif",
      style: 'pointer-events:none'
    }, lib.n.charAt(0).toUpperCase()));

    // Document count badge
    const badgeY = -bH / 2;
    const countStr = String(lib.c);
    const badgeW = Math.max(8, countStr.length * 4 + 4) * libScale;
    const badgeH = 6 * libScale;
    bldgG.appendChild(svgEl('rect', {
      x: String((-badgeW / 2).toFixed(1)), y: String((badgeY - badgeH / 2).toFixed(1)),
      width: String(badgeW.toFixed(1)), height: String(badgeH.toFixed(1)),
      rx: String((badgeH / 2).toFixed(1)), fill: 'rgba(0,0,0,0.55)'
    }));
    bldgG.appendChild(svgEl('text', {
      x: '0', y: String((badgeY + 0.5).toFixed(1)),
      'text-anchor': 'middle', 'dominant-baseline': 'central',
      fill: '#fff', 'font-size': String((4.5 * libScale).toFixed(1)),
      'font-weight': '700',
      'font-family': "'Segoe UI',system-ui,sans-serif",
      style: 'pointer-events:none'
    }, countStr));

    g.appendChild(bldgG);
  });

  // === Layer 9: Site type icon (Team Site vs Communication Site) ===
  const stIcon = svgEl('g', {
    transform: 'translate(0,' + (-ry * 0.35) + ')',
    opacity: '0.7', style: 'pointer-events:none'
  });
  const stIsComm = COMM_SITES.has(isl.id);
  const stS = isHub ? 1.3 : 0.9; // scale factor
  if (stIsComm) {
    // Communication Site: broadcast tower / megaphone icon
    const mc = isHub ? '#d4a843' : '#a0b8c8';
    // Tower base
    stIcon.appendChild(svgEl('rect', {
      x: String(-2 * stS), y: String(-2 * stS), width: String(4 * stS), height: String(12 * stS),
      rx: '1', fill: mc
    }));
    // Tower top disc
    stIcon.appendChild(svgEl('ellipse', {
      cx: '0', cy: String(-3 * stS), rx: String(3.5 * stS), ry: String(2 * stS),
      fill: 'none', stroke: mc, 'stroke-width': String(1.2 * stS)
    }));
    // Broadcast waves (3 arcs)
    for (let w = 0; w < 3; w++) {
      const wr = (6 + w * 4) * stS;
      stIcon.appendChild(svgEl('path', {
        d: 'M' + (-wr * 0.7).toFixed(1) + ',' + (-3 * stS - wr * 0.4).toFixed(1) +
           ' A' + wr.toFixed(1) + ',' + wr.toFixed(1) + ' 0 0,1 ' +
           (wr * 0.7).toFixed(1) + ',' + (-3 * stS - wr * 0.4).toFixed(1),
        fill: 'none', stroke: mc, 'stroke-width': String(0.8 * stS),
        opacity: String((0.6 - w * 0.15).toFixed(2))
      }));
    }
  } else {
    // Team Site: people silhouettes icon
    const pc = '#8ab8d8';
    // Center person (slightly larger)
    stIcon.appendChild(svgEl('circle', { cx: '0', cy: String(-1 * stS), r: String(3 * stS), fill: pc }));
    stIcon.appendChild(svgEl('path', {
      d: 'M' + (-5 * stS) + ',' + (9 * stS) + ' Q' + (-5 * stS) + ',' + (3 * stS) + ' 0,' + (3 * stS) +
         ' Q' + (5 * stS) + ',' + (3 * stS) + ' ' + (5 * stS) + ',' + (9 * stS),
      fill: pc
    }));
    // Left person (smaller, behind)
    stIcon.appendChild(svgEl('circle', { cx: String(-7 * stS), cy: String(0 * stS), r: String(2.3 * stS), fill: pc, opacity: '0.6' }));
    stIcon.appendChild(svgEl('path', {
      d: 'M' + (-11 * stS) + ',' + (9 * stS) + ' Q' + (-11 * stS) + ',' + (4 * stS) + ' ' + (-7 * stS) + ',' + (4 * stS) +
         ' Q' + (-3 * stS) + ',' + (4 * stS) + ' ' + (-3 * stS) + ',' + (9 * stS),
      fill: pc, opacity: '0.6'
    }));
    // Right person (smaller, behind)
    stIcon.appendChild(svgEl('circle', { cx: String(7 * stS), cy: String(0 * stS), r: String(2.3 * stS), fill: pc, opacity: '0.6' }));
    stIcon.appendChild(svgEl('path', {
      d: 'M' + (3 * stS) + ',' + (9 * stS) + ' Q' + (3 * stS) + ',' + (4 * stS) + ' ' + (7 * stS) + ',' + (4 * stS) +
         ' Q' + (11 * stS) + ',' + (4 * stS) + ' ' + (11 * stS) + ',' + (9 * stS),
      fill: pc, opacity: '0.6'
    }));
  }
  g.appendChild(stIcon);

  // === Layer 10: Activity indicator ===
  const actColors = {high:'#50bb4e', medium:'#e8b020', low:'#888'};
  const actColor = actColors[isl.activity] || '#888';
  const actG = svgEl('g');
  actG.appendChild(svgEl('circle', {
    cx: String(rx * 0.55), cy: String(-ry * 0.55), r: '5',
    fill: actColor, stroke: '#fff', 'stroke-width': '1.5', opacity: '0.9'
  }));
  if (isl.activity === 'high') {
    actG.appendChild(svgEl('circle', {
      cx: String(rx * 0.55), cy: String(-ry * 0.55), r: '5',
      fill: 'none', stroke: actColor, 'stroke-width': '2', opacity: '0.6'
    })).innerHTML = '<animate attributeName="r" values="5;10;5" dur="2s" repeatCount="indefinite"/><animate attributeName="opacity" values="0.6;0;0.6" dur="2s" repeatCount="indefinite"/>';
    // Manually create animated pulse
    const pulseCircle = svgEl('circle', {
      cx: String(rx * 0.55), cy: String(-ry * 0.55), r: '5',
      fill: 'none', stroke: actColor, 'stroke-width': '2', opacity: '0.6'
    });
    const animR = svgEl('animate', {attributeName: 'r', values: '5;11;5', dur: '2s', repeatCount: 'indefinite'});
    const animO = svgEl('animate', {attributeName: 'opacity', values: '0.6;0;0.6', dur: '2s', repeatCount: 'indefinite'});
    pulseCircle.appendChild(animR);
    pulseCircle.appendChild(animO);
    actG.appendChild(pulseCircle);
  }
  g.appendChild(actG);

  // === Site type ring (Comm = gold/amber, Team = blue) ===
  const stRingComm = COMM_SITES.has(isl.id);
  if (isHub) {
    // Hub: bold ring
    g.appendChild(svgEl('path', {
      d: blobPath(0, 0, rx + 4, ry + 3, seed + 50, 12),
      fill: 'none',
      stroke: stRingComm ? 'rgba(212,168,67,0.45)' : 'rgba(100,160,210,0.45)',
      'stroke-width': '2.5'
    }));
  } else {
    // Non-hub: thinner dashed ring
    g.appendChild(svgEl('path', {
      d: blobPath(0, 0, rx + 3, ry + 2, seed + 50, 12),
      fill: 'none',
      stroke: stRingComm ? 'rgba(200,160,60,0.25)' : 'rgba(80,140,200,0.25)',
      'stroke-width': '1.5',
      'stroke-dasharray': stRingComm ? 'none' : '4 3'
    }));
  }

  // === Fog of War (unvisited) ===
  if (!isl.visited) {
    const fogG = svgEl('g', {filter: 'url(#fogFilter)', opacity: '0.6'});
    fogG.appendChild(svgEl('path', {
      d: blobPath(0, 0, rx + 15, ry + 12, seed + 800, 12),
      fill: 'rgba(20,30,50,0.55)'
    }));
    g.appendChild(fogG);
  }

  // === Label ===
  const labelY = ry * 0.65 + 18;
  const labelBg = isHub ? 'rgba(120,95,35,0.88)' : 'rgba(20,35,25,0.82)';
  const labelBorder = isHub ? 'rgba(180,150,80,0.3)' : 'rgba(100,130,100,0.2)';
  const labelColor = isHub ? '#ffe080' : '#e0e8e0';
  const fontSize = isHub ? 12 : 10;
  const stPrefix = COMM_SITES.has(isl.id) ? (isHub ? '\u2605 ' : '\u25C8 ') : '\u25CB ';
  const labelText = stPrefix + isl.name;
  const textWidth = labelText.length * fontSize * 0.52;
  const pillW = textWidth + 20;
  const pillH = fontSize + 12;

  // Sub-label (document count)
  const subFontSize = isHub ? 8 : 7;
  const stLabel = COMM_SITES.has(isl.id) ? 'Komm' : 'Team';
  const subText = stLabel + ' \u00b7 ' + isl.docs + ' dok';
  const subTextWidth = subText.length * subFontSize * 0.52;
  const subPillW = subTextWidth + 12;
  const subPillH = subFontSize + 8;
  const subLabelY = labelY + pillH / 2 + subPillH / 2 + 2;

  // Label sub-group with transform-origin for hover scaling
  const labelGroup = svgEl('g', {
    class: 'island-label',
    style: 'transform-origin: 0px ' + labelY + 'px'
  });

  // --- Parchment path helper ---
  function parchmentRect(cx, cy, w, h, rngRef) {
    const hw = w / 2;
    const hh = h / 2;
    const steps = 8;
    const sx = w / steps;
    const jV = h * 0.08;
    const jH = w * 0.04;
    let d = 'M ' + (-hw + 3) + ' ' + (cy - hh);
    for (let i = 1; i < steps; i++) {
      const px = -hw + i * sx;
      const py = cy - hh + (rngRef() - 0.5) * jV;
      d += ' L ' + px.toFixed(1) + ' ' + py.toFixed(1);
    }
    d += ' L ' + (hw - 3) + ' ' + (cy - hh);
    d += ' Q ' + (hw + (rngRef() - 0.5) * jH).toFixed(1) + ' ' + cy.toFixed(1) + ' ' + (hw - 3) + ' ' + (cy + hh);
    for (let i = steps - 1; i > 0; i--) {
      const px = -hw + i * sx;
      const py = cy + hh + (rngRef() - 0.5) * jV;
      d += ' L ' + px.toFixed(1) + ' ' + py.toFixed(1);
    }
    d += ' L ' + (-hw + 3) + ' ' + (cy + hh);
    d += ' Q ' + (-hw + (rngRef() - 0.5) * jH).toFixed(1) + ' ' + cy.toFixed(1) + ' ' + (-hw + 3) + ' ' + (cy - hh);
    d += ' Z';
    return d;
  }

  // --- Drop shadow ---
  labelGroup.appendChild(svgEl('path', {
    d: parchmentRect(1, labelY + 1, pillW, pillH, rng),
    fill: 'rgba(0,0,0,0.35)', 'stroke-width': '0'
  }));

  // --- Parchment label background ---
  labelGroup.appendChild(svgEl('path', {
    d: parchmentRect(0, labelY, pillW, pillH, rng),
    fill: labelBg, stroke: labelBorder, 'stroke-width': '1'
  }));

  // --- Main label text ---
  if (isHub) {
    const mainTextEl = svgEl('text', {
      x: '0', y: String(labelY + 1),
      'text-anchor': 'middle', 'dominant-baseline': 'central',
      'font-size': String(fontSize), 'font-weight': '700',
      'font-family': "'Segoe UI',system-ui,sans-serif",
      style: 'pointer-events:none'
    });
    const starSpan = svgEl('tspan', { fill: '#d4a843' }, '\u2605 ');
    const restSpan = svgEl('tspan', { fill: labelColor }, isl.name);
    mainTextEl.appendChild(starSpan);
    mainTextEl.appendChild(restSpan);
    labelGroup.appendChild(mainTextEl);
  } else {
    labelGroup.appendChild(svgEl('text', {
      x: '0', y: String(labelY + 1),
      'text-anchor': 'middle', 'dominant-baseline': 'central',
      fill: labelColor, 'font-size': String(fontSize),
      'font-weight': '500',
      'font-family': "'Segoe UI',system-ui,sans-serif",
      style: 'pointer-events:none'
    }, isl.name));
  }

  // --- Sub-label shadow ---
  labelGroup.appendChild(svgEl('path', {
    d: parchmentRect(1, subLabelY + 1, subPillW, subPillH, rng),
    fill: 'rgba(0,0,0,0.2)', 'stroke-width': '0'
  }));

  // --- Sub-label background ---
  labelGroup.appendChild(svgEl('path', {
    d: parchmentRect(0, subLabelY, subPillW, subPillH, rng),
    fill: isHub ? 'rgba(120,95,35,0.7)' : 'rgba(20,35,25,0.65)',
    stroke: isHub ? 'rgba(180,150,80,0.2)' : 'rgba(100,130,100,0.15)',
    'stroke-width': '0.5'
  }));

  // --- Sub-label text (doc count) ---
  labelGroup.appendChild(svgEl('text', {
    x: '0', y: String(subLabelY + 1),
    'text-anchor': 'middle', 'dominant-baseline': 'central',
    fill: isHub ? 'rgba(255,224,128,0.7)' : 'rgba(200,215,200,0.6)',
    'font-size': String(subFontSize), 'font-weight': '400',
    'font-family': "'Segoe UI',system-ui,sans-serif",
    style: 'pointer-events:none'
  }, subText));

  g.appendChild(labelGroup);

  // Click handler (navigate mode)
  g.addEventListener('click', (e) => {
    e.stopPropagation();
    if (dragMoved) { dragMoved = false; return; }
    if (editMode) return;
    selectIsland(isl);
  });

  // Drag handler (edit/arrange mode)
  g.addEventListener('mousedown', (e) => {
    if (!editMode) return;
    e.stopPropagation();
    e.preventDefault();
    isDragging = true;
    dragIsland = isl;
    dragStartMX = e.clientX;
    dragStartMY = e.clientY;
    dragOrigX = isl.x;
    dragOrigY = isl.y;
    dragMoved = false;
    g.classList.add('dragging');
    container.classList.add('grabbing');
  });

  parentG.appendChild(g);
}

// ========== BUILD DECORATIONS ==========
function buildDecorations() {
  const g = svgEl('g', {class: 'decorations', 'pointer-events': 'none'});

  // â”€â”€ 1. Sea Monster / Kraken â”€â”€
  const kraken = svgEl('g', {transform: 'translate(-800,-200)', opacity: '0.18'});

  // Body â€” large oval
  kraken.appendChild(svgEl('ellipse', {cx: '0', cy: '0', rx: '55', ry: '30', fill: '#0a3d4a', stroke: '#072e38', 'stroke-width': '1.5'}));
  // Head bump
  kraken.appendChild(svgEl('ellipse', {cx: '42', cy: '-8', rx: '22', ry: '18', fill: '#0c4456'}));

  // Eyes â€” gold/yellow
  kraken.appendChild(svgEl('circle', {cx: '50', cy: '-14', r: '5', fill: '#d4a843'}));
  kraken.appendChild(svgEl('circle', {cx: '50', cy: '-14', r: '2.5', fill: '#1a1a1a'}));
  kraken.appendChild(svgEl('circle', {cx: '38', cy: '-14', r: '4.5', fill: '#d4a843'}));
  kraken.appendChild(svgEl('circle', {cx: '38', cy: '-14', r: '2.2', fill: '#1a1a1a'}));

  // Tentacles â€” 5 curved bezier paths radiating outward
  const tentacles = [
    'M -50,10 C -90,30 -130,15 -145,40',
    'M -45,22 C -80,55 -115,50 -135,75',
    'M -30,28 C -50,65 -75,80 -90,110',
    'M 15,28 C 30,60 55,75 45,105',
    'M 35,22 C 60,50 85,55 100,80'
  ];
  tentacles.forEach(d => {
    kraken.appendChild(svgEl('path', {d: d, fill: 'none', stroke: '#0a3d4a', 'stroke-width': '5', 'stroke-linecap': 'round'}));
    // Thinner inner stroke for depth
    kraken.appendChild(svgEl('path', {d: d, fill: 'none', stroke: '#0e4e5c', 'stroke-width': '2.5', 'stroke-linecap': 'round'}));
  });

  // Suction cups on tentacles (small circles along paths)
  const cups = [
    {cx: -100, cy: 22}, {cx: -125, cy: 30}, {cx: -140, cy: 38},
    {cx: -85, cy: 48}, {cx: -115, cy: 55}, {cx: -130, cy: 70},
    {cx: -55, cy: 60}, {cx: -75, cy: 82}, {cx: -88, cy: 105},
    {cx: 35, cy: 55}, {cx: 42, cy: 80}, {cx: 44, cy: 100},
    {cx: 65, cy: 50}, {cx: 85, cy: 58}, {cx: 95, cy: 75}
  ];
  cups.forEach(c => {
    kraken.appendChild(svgEl('circle', {cx: String(c.cx), cy: String(c.cy), r: '2.5', fill: 'none', stroke: '#0e5560', 'stroke-width': '0.8'}));
  });

  g.appendChild(kraken);

  // â”€â”€ 2. "HÃ¤r bor drakar" text â”€â”€
  const drakarText = svgEl('text', {
    x: '100', y: '-700',
    fill: 'rgba(180,160,120,0.12)',
    'font-family': 'Georgia, serif',
    'font-size': '30',
    'font-style': 'italic',
    transform: 'rotate(5, 100, -700)',
    'letter-spacing': '3'
  }, 'HÃ¤r bor drakar');
  g.appendChild(drakarText);

  // â”€â”€ 3. Wind Rose Lines â”€â”€
  const windRose = svgEl('g', {transform: 'translate(-1100,-700)'});
  const directions = [
    {x2: 0, y2: -600},    // N
    {x2: 0, y2: 600},     // S
    {x2: 600, y2: 0},     // E
    {x2: -600, y2: 0}     // W
  ];
  directions.forEach(dir => {
    windRose.appendChild(svgEl('line', {
      x1: '0', y1: '0',
      x2: String(dir.x2), y2: String(dir.y2),
      stroke: 'rgba(200,180,140,0.05)',
      'stroke-width': '0.4',
      'stroke-dasharray': '12,8'
    }));
  });
  g.appendChild(windRose);

  // â”€â”€ 4. Decorative Map Border â”€â”€
  const border = svgEl('g', {class: 'map-border'});
  const bx1 = -1300, by1 = -900, bx2 = 1300, by2 = 1000;
  const borderColor = 'rgba(180,160,120,0.08)';
  const borderW = '0.5';

  // Outer frame
  border.appendChild(svgEl('rect', {
    x: String(bx1), y: String(by1),
    width: String(bx2 - bx1), height: String(by2 - by1),
    fill: 'none', stroke: borderColor, 'stroke-width': borderW
  }));
  // Inner frame (inset 12px)
  const ins = 12;
  border.appendChild(svgEl('rect', {
    x: String(bx1 + ins), y: String(by1 + ins),
    width: String(bx2 - bx1 - ins * 2), height: String(by2 - by1 - ins * 2),
    fill: 'none', stroke: borderColor, 'stroke-width': borderW
  }));

  // Corner flourishes â€” baroque scrollwork spirals
  const cornerPositions = [
    {x: bx1, y: by1, sx: 1, sy: 1},    // top-left
    {x: bx2, y: by1, sx: -1, sy: 1},    // top-right
    {x: bx1, y: by2, sx: 1, sy: -1},    // bottom-left
    {x: bx2, y: by2, sx: -1, sy: -1}    // bottom-right
  ];

  cornerPositions.forEach(corner => {
    const cf = svgEl('g', {
      transform: 'translate(' + corner.x + ',' + corner.y + ') scale(' + corner.sx + ',' + corner.sy + ')'
    });

    // Main spiral scroll
    cf.appendChild(svgEl('path', {
      d: 'M 0,0 C 5,20 15,35 30,40 C 40,42 45,35 40,25 C 35,18 25,18 22,25 C 20,30 25,34 30,32',
      fill: 'none', stroke: borderColor, 'stroke-width': '0.7'
    }));
    // Second outward curl
    cf.appendChild(svgEl('path', {
      d: 'M 0,0 C 20,5 35,15 40,30 C 42,40 35,45 25,40 C 18,35 18,25 25,22 C 30,20 34,25 32,30',
      fill: 'none', stroke: borderColor, 'stroke-width': '0.7'
    }));
    // Small inner ornament dot
    cf.appendChild(svgEl('circle', {
      cx: '8', cy: '8', r: '2',
      fill: 'none', stroke: borderColor, 'stroke-width': '0.5'
    }));
    // Filigree leaf
    cf.appendChild(svgEl('path', {
      d: 'M 12,2 C 18,6 24,4 28,10 C 24,12 18,10 12,2 Z',
      fill: borderColor, stroke: 'none'
    }));
    // Outer accent arc
    cf.appendChild(svgEl('path', {
      d: 'M 0,50 C 10,48 40,48 50,0',
      fill: 'none', stroke: borderColor, 'stroke-width': '0.4'
    }));

    border.appendChild(cf);
  });

  g.appendChild(border);

  // â”€â”€ 5. Lighthouses â”€â”€
  const lighthouses = [
    {x: -960, y: -580},
    {x: 810, y: 480},
    {x: -760, y: 700}
  ];

  lighthouses.forEach(pos => {
    const lh = svgEl('g', {transform: 'translate(' + pos.x + ',' + pos.y + ')', opacity: '0.35'});

    // Glow behind the light
    lh.appendChild(svgEl('circle', {
      cx: '0', cy: '-22', r: '10',
      fill: 'rgba(255,240,150,0.3)'
    }));

    // Base â€” vertical rectangle (tapered slightly)
    lh.appendChild(svgEl('path', {
      d: 'M -4,0 L -3,-18 L 3,-18 L 4,0 Z',
      fill: '#8b7355', stroke: '#6b5540', 'stroke-width': '0.5'
    }));

    // Red/white stripes on tower
    lh.appendChild(svgEl('rect', {x: '-3', y: '-14', width: '6', height: '3', fill: '#b34040', opacity: '0.8'}));
    lh.appendChild(svgEl('rect', {x: '-3', y: '-8', width: '6', height: '3', fill: '#b34040', opacity: '0.8'}));

    // Roof â€” triangle
    lh.appendChild(svgEl('polygon', {
      points: '0,-25 -5,-18 5,-18',
      fill: '#5a4a3a', stroke: '#4a3a2a', 'stroke-width': '0.5'
    }));

    // Gallery/balcony ledge
    lh.appendChild(svgEl('line', {
      x1: '-5', y1: '-18', x2: '5', y2: '-18',
      stroke: '#6b5540', 'stroke-width': '1'
    }));

    // Light â€” bright circle
    lh.appendChild(svgEl('circle', {
      cx: '0', cy: '-20', r: '2.5',
      fill: '#ffe680', stroke: '#d4a843', 'stroke-width': '0.5'
    }));

    // Light rays (subtle)
    [-35, 0, 35].forEach(angle => {
      const rad = (angle - 90) * Math.PI / 180;
      const x2 = Math.cos(rad) * 14;
      const y2 = -20 + Math.sin(rad) * 14;
      lh.appendChild(svgEl('line', {
        x1: '0', y1: '-20',
        x2: String(x2.toFixed(1)), y2: String(y2.toFixed(1)),
        stroke: 'rgba(255,230,130,0.25)',
        'stroke-width': '0.6'
      }));
    });

    g.appendChild(lh);
  });

  return g;
}

// ========== SMIL ANIMATIONS (post-build overlay) ==========
function addAnimations() {
  // Remove any previous animation overlay (in case of rebuild)
  const prev = svg.querySelector('#animation-overlay');
  if (prev) prev.remove();

  const ag = svgEl('g', {id: 'animation-overlay', 'pointer-events': 'none'});
  const animRng = lcg(31415);

  // â”€â”€ 1. Flying Birds â€” V-shaped silhouettes along bezier paths â”€â”€
  const birdPaths = [
    {id: 'birdPath1', d: 'M-1400,-500 C-800,-600 -200,-200 400,-450 C800,-600 1100,-300 1500,-400'},
    {id: 'birdPath2', d: 'M1500,300 C1000,150 500,400 0,200 C-500,0 -900,250 -1400,100'},
    {id: 'birdPath3', d: 'M-1300,700 C-700,500 -100,750 500,550 C900,400 1200,600 1500,500'}
  ];

  // Add bird motion paths to defs
  const defs = svg.querySelector('defs');
  birdPaths.forEach(bp => {
    // Remove old one if exists (rebuild case)
    const oldPath = defs.querySelector('#' + bp.id);
    if (oldPath) oldPath.remove();
    defs.appendChild(svgEl('path', {id: bp.id, d: bp.d, fill: 'none', stroke: 'none'}));
  });

  birdPaths.forEach((bp, i) => {
    const dur = (35 + animRng() * 25).toFixed(0) + 's';
    const delay = (animRng() * 10).toFixed(1) + 's';
    const birdG = svgEl('g', {opacity: '0.35'});

    // Bird shape: simple V
    const bird = svgEl('path', {
      d: 'M-3,-1 L0,1 L3,-1',
      fill: 'none', stroke: '#1a2a1a', 'stroke-width': '0.8', 'stroke-linecap': 'round', 'stroke-linejoin': 'round'
    });

    // animateMotion with mpath
    const motion = svgEl('animateMotion', {
      dur: dur,
      begin: delay,
      repeatCount: 'indefinite',
      rotate: 'auto'
    });
    const mpath = svgEl('mpath', {'href': '#' + bp.id});
    // Also set xlink:href for broader browser support
    mpath.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', '#' + bp.id);
    motion.appendChild(mpath);
    bird.appendChild(motion);

    birdG.appendChild(bird);

    // Second bird slightly offset (flock effect)
    const bird2 = svgEl('path', {
      d: 'M-2.5,-0.8 L0,0.8 L2.5,-0.8',
      fill: 'none', stroke: '#1a2a1a', 'stroke-width': '0.7', 'stroke-linecap': 'round', 'stroke-linejoin': 'round'
    });
    const motion2 = svgEl('animateMotion', {
      dur: dur,
      begin: (parseFloat(delay) + 1.5).toFixed(1) + 's',
      repeatCount: 'indefinite',
      rotate: 'auto',
      keyPoints: '0.02;1;0.02',
      keyTimes: '0;0.98;1'
    });
    const mpath2 = svgEl('mpath', {'href': '#' + bp.id});
    mpath2.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', '#' + bp.id);
    motion2.appendChild(mpath2);
    bird2.appendChild(motion2);
    birdG.appendChild(bird2);

    ag.appendChild(birdG);
  });

  // â”€â”€ 3. Wave Lap on Shores â€” animated arcs near large islands â”€â”€
  const largeIslands = islands.filter(isl => isl.rx >= 60).slice(0, 8);
  let waveLapIdx = 0;
  largeIslands.forEach(isl => {
    const numLaps = 3 + Math.floor(animRng() * 3); // 3-5
    for (let w = 0; w < numLaps; w++) {
      const wAngle = animRng() * Math.PI * 2;
      const wDist = isl.rx + 12 + animRng() * 8;
      const wDistY = (isl.ry + 12 + animRng() * 8) * 0.65;
      const wcx = isl.x + Math.cos(wAngle) * wDist;
      const wcy = isl.y + Math.sin(wAngle) * wDistY;
      const arcSpan = 18 + animRng() * 14;
      const arcRad = arcSpan * (Math.PI / 180);
      const arcR = 8 + animRng() * 6;
      const ax1 = wcx + Math.cos(wAngle - arcRad / 2) * arcR;
      const ay1 = wcy + Math.sin(wAngle - arcRad / 2) * arcR * 0.65;
      const ax2 = wcx + Math.cos(wAngle + arcRad / 2) * arcR;
      const ay2 = wcy + Math.sin(wAngle + arcRad / 2) * arcR * 0.65;

      const waveArc = svgEl('path', {
        d: 'M' + ax1.toFixed(1) + ',' + ay1.toFixed(1) + ' A' + arcR.toFixed(1) + ',' + (arcR * 0.65).toFixed(1) + ' 0 0,1 ' + ax2.toFixed(1) + ',' + ay2.toFixed(1),
        fill: 'none', stroke: 'rgba(255,255,255,0.2)', 'stroke-width': '1.2', 'stroke-linecap': 'round',
        opacity: '0'
      });

      const stagger = (waveLapIdx * 1.3).toFixed(1) + 's';
      const dur = (3.5 + animRng() * 1.5).toFixed(1) + 's';
      waveArc.appendChild(svgEl('animate', {
        attributeName: 'opacity', values: '0;0.18;0', dur: dur, begin: stagger, repeatCount: 'indefinite'
      }));
      ag.appendChild(waveArc);
      waveLapIdx++;
    }
  });

  // â”€â”€ 4. Volcanic Smoke Drift â€” smoke puffs rising from volcanic islands â”€â”€
  const volcanicIslands = islands.filter(isl => isl.terrain === 'volcanic');
  volcanicIslands.forEach(isl => {
    const numPuffs = 2 + Math.floor(animRng() * 2); // 2-3
    for (let p = 0; p < numPuffs; p++) {
      const px = isl.x + (animRng() - 0.5) * 10;
      const py = isl.y - isl.ry * 0.65 - 5; // above the island
      const puffR = 3 + animRng() * 2;
      const dur = (5 + animRng() * 3).toFixed(1) + 's';
      const delay = (p * 1.8 + animRng() * 1).toFixed(1) + 's';
      const driftX = (animRng() - 0.3) * 8; // slight horizontal drift

      const puff = svgEl('circle', {
        cx: String(px.toFixed(1)), cy: String(py.toFixed(1)), r: String(puffR.toFixed(1)),
        fill: 'rgba(80,80,80,0.2)', opacity: '0'
      });

      // Rise + drift
      puff.appendChild(svgEl('animateTransform', {
        attributeName: 'transform',
        type: 'translate',
        values: '0,0;' + (driftX * 0.5).toFixed(1) + ',-15;' + driftX.toFixed(1) + ',-30',
        dur: dur, begin: delay, repeatCount: 'indefinite'
      }));

      // Fade in then out
      puff.appendChild(svgEl('animate', {
        attributeName: 'opacity', values: '0;0.2;0.15;0', dur: dur, begin: delay, repeatCount: 'indefinite'
      }));

      // Expand slightly as it rises
      puff.appendChild(svgEl('animate', {
        attributeName: 'r',
        values: puffR.toFixed(1) + ';' + (puffR * 1.3).toFixed(1) + ';' + (puffR * 1.8).toFixed(1),
        dur: dur, begin: delay, repeatCount: 'indefinite'
      }));

      ag.appendChild(puff);
    }
  });

  // â”€â”€ 5. Boat Bobbing â€” gentle vertical motion on decorative boats â”€â”€
  const boatGroup = svg.querySelector('#decorative-boats');
  if (boatGroup) {
    const boats = boatGroup.querySelectorAll('g');
    boats.forEach((boat, i) => {
      const dur = (2.5 + i * 0.5).toFixed(1) + 's';
      const delay = (i * 0.8).toFixed(1) + 's';

      // Add bobbing translate animation
      const bob = svgEl('animateTransform', {
        attributeName: 'transform',
        type: 'translate',
        values: '0,0;0,-2;0,0',
        dur: dur,
        begin: delay,
        repeatCount: 'indefinite',
        additive: 'sum'
      });
      boat.appendChild(bob);

      // Add very slight rotation for realistic rocking
      const rock = svgEl('animateTransform', {
        attributeName: 'transform',
        type: 'rotate',
        values: '0;2;0;-1.5;0',
        dur: (parseFloat(dur) * 1.3).toFixed(1) + 's',
        begin: delay,
        repeatCount: 'indefinite',
        additive: 'sum'
      });
      boat.appendChild(rock);
    });
  }

  svg.appendChild(ag);
  // Immediately apply current transform so the layer is visible
  updateTransform();
}

// ========== BUILD ENTIRE MAP ==========
function buildMap() {
  svg.innerHTML = '';
  svg.appendChild(buildDefs());
  svg.appendChild(buildOcean());

  // Bridges layer
  const bridgeG = svgEl('g', {id: 'bridge-layer'});
  const hubMap = {};
  islands.forEach(i => { if (i.type === 'hub') hubMap[i.id] = i; });
  islands.forEach(i => {
    if (i.hubId && hubMap[i.hubId]) {
      drawBridge(bridgeG, hubMap[i.hubId], i);
    }
  });
  svg.appendChild(bridgeG);

  // Decorations layer (sea monster, text, wind lines, border, lighthouses)
  svg.appendChild(buildDecorations());

  // Islands layer - sort by y for depth
  const sorted = [...islands].sort((a, b) => a.y - b.y);
  const islandG = svgEl('g', {id: 'island-layer'});
  sorted.forEach((isl, idx) => {
    const origIdx = islands.indexOf(isl);
    drawIsland(islandG, isl, origIdx);
  });
  svg.appendChild(islandG);

  // Atmosphere overlay (vignette, god-rays, fog, tint)
  svg.appendChild(buildAtmosphere());

  updateTransform();
}

// ========== TRANSFORM ==========
function updateTransform() {
  const cw = container.clientWidth, ch = container.clientHeight;
  const tx = cw / 2 + panX;
  const ty = ch / 2 + panY;
  // Apply transform to all SVG content via a viewBox-independent approach
  const layers = svg.querySelectorAll('#ocean-layer, #bridge-layer, .decorations, #island-layer, .atmosphere, #animation-overlay');
  layers.forEach(l => {
    l.setAttribute('transform', 'translate(' + tx + ',' + ty + ') scale(' + scale + ')');
  });
  updateMinimap();
}


// ========== ISLAND SELECTION ==========
function selectIsland(isl) {
  selectedIsland = isl;
  isl.visited = true;

  // Update detail panel
  const stTpl = COMM_SITES.has(isl.id) ? 'Kommunikationswebbplats' : 'Gruppwebbplats';
  document.getElementById('dp-emoji').textContent = COMM_SITES.has(isl.id) ? '\u{1F4E1}' : '\u{1F465}';
  document.getElementById('dp-name').textContent = isl.name;
  const typeLabels = {hub:'Hub',satellite:'Satellit',dept:'Avdelning',project:'Projekt'};
  document.getElementById('dp-type').textContent = (typeLabels[isl.type] || isl.type) + ' \u00b7 ' + stTpl;
  document.getElementById('dp-terrain').textContent = 'TerrÃ¤ngtyp: ' + (TERRAIN_NAMES[isl.terrain] || isl.terrain);
  document.getElementById('dp-desc').textContent = isl.desc;
  document.getElementById('dp-docs').textContent = String(isl.docs);
  document.getElementById('dp-libcount').textContent = String(isl.libs.length);
  const actLabels = {high:'HÃ¶g', medium:'Medel', low:'LÃ¥g'};
  document.getElementById('dp-activity').textContent = actLabels[isl.activity] || isl.activity;

  const libList = document.getElementById('dp-lib-list');
  libList.innerHTML = '';
  isl.libs.forEach(lib => {
    const row = document.createElement('div');
    row.className = 'dp-lib';
    row.innerHTML = '<div class="lib-icon">' + lib.i + '</div><span>' + lib.n + '</span><span class="lib-count">' + lib.c + ' dok</span>';
    libList.appendChild(row);
  });

  detailPanel.classList.add('open');

  // Animate ship
  animateShip(isl);

  // Remove fog overlay from this island
  removeFog(isl);

  showToast('Navigerar till ' + isl.name);
}

function removeFog(isl) {
  // Re-render could be expensive; simpler to just remove fog overlay from the DOM
  const groups = svg.querySelectorAll('[data-id="' + isl.id + '"]');
  groups.forEach(g => {
    const fogChildren = g.querySelectorAll('[filter="url(#fogFilter)"]');
    fogChildren.forEach(f => f.remove());
  });
}

function animateShip(isl) {
  if (shipAnim) cancelAnimationFrame(shipAnim);
  const ship = shipEl;
  const startPos = ship.style.left ? {x: parseFloat(ship.style.left), y: parseFloat(ship.style.top)} : worldToScreen(0, 0);
  const endPos = worldToScreen(isl.x, isl.y);

  ship.classList.add('sailing');
  const duration = 1200;
  const startTime = performance.now();

  function step(time) {
    const t = Math.min(1, (time - startTime) / duration);
    const ease = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
    const cx = startPos.x + (endPos.x - startPos.x) * ease;
    const cy = startPos.y + (endPos.y - startPos.y) * ease;
    ship.style.left = (cx - 16) + 'px';
    ship.style.top = (cy - 16) + 'px';

    if (t < 1) {
      shipAnim = requestAnimationFrame(step);
    } else {
      // Bob animation
      ship.style.transition = 'transform 2s ease-in-out';
    }
  }
  shipAnim = requestAnimationFrame(step);
}

// ========== MINIMAP ==========
function updateMinimap() {
  const ctx = minimapCtx;
  const cw = 400, ch = 300;
  ctx.clearRect(0, 0, cw, ch);

  // Background
  ctx.fillStyle = '#0a2a4a';
  ctx.fillRect(0, 0, cw, ch);

  // Map bounds
  const mapMinX = -1150, mapMaxX = 1200, mapMinY = -750, mapMaxY = 950;
  const mapW = mapMaxX - mapMinX, mapH = mapMaxY - mapMinY;
  const sx = cw / mapW, sy = ch / mapH;
  const ms = Math.min(sx, sy) * 0.9;
  const ox = cw / 2, oy = ch / 2;

  // Draw islands
  islands.forEach(isl => {
    const ix = ox + isl.x * ms;
    const iy = oy + isl.y * ms;
    const r = Math.max(2, Math.sqrt(isl.rx * isl.ry) * ms * 0.3);

    ctx.fillStyle = isl.type === 'hub' ? '#d4a843' : (isl.visited ? '#50bb4e' : '#556');
    ctx.beginPath();
    ctx.arc(ix, iy, r, 0, Math.PI * 2);
    ctx.fill();
  });

  // Viewport rectangle
  const containerW = container.clientWidth, containerH = container.clientHeight;
  const tlWorld = screenToWorld(0, 0);
  const brWorld = screenToWorld(containerW, containerH);

  const vpLeft = ox + tlWorld.x * ms;
  const vpTop = oy + tlWorld.y * ms;
  const vpW = (brWorld.x - tlWorld.x) * ms;
  const vpH = (brWorld.y - tlWorld.y) * ms;

  const vpEl = document.getElementById('minimap-vp');
  vpEl.style.left = Math.max(0, vpLeft) + 'px';
  vpEl.style.top = Math.max(0, vpTop) + 'px';
  vpEl.style.width = Math.min(cw, vpW) + 'px';
  vpEl.style.height = Math.min(ch, vpH) + 'px';
}

// ========== PAN & ZOOM ==========
container.addEventListener('mousedown', e => {
  if (e.target.closest('.island-group')) return;
  isPanning = true;
  panStartX = e.clientX;
  panStartY = e.clientY;
  panStartPX = panX;
  panStartPY = panY;
  container.classList.add('grabbing');
});

window.addEventListener('mousemove', e => {
  // Handle island dragging (edit mode)
  if (isDragging && dragIsland) {
    const dx = (e.clientX - dragStartMX) / scale;
    const dy = (e.clientY - dragStartMY) / scale;
    if (Math.abs(dx) > 2 || Math.abs(dy) > 2) dragMoved = true;
    if (dragMoved) {
      dragIsland.x = dragOrigX + dx;
      dragIsland.y = dragOrigY + dy;
      // Live-update the island SVG group transform
      const el = svg.querySelector('.island-group[data-id="' + dragIsland.id + '"]');
      if (el) el.setAttribute('transform', 'translate(' + dragIsland.x + ',' + dragIsland.y + ')');
      // Live-update bridges connected to this island
      rebuildBridges();
    }
    return;
  }
  if (!isPanning) return;
  panX = panStartPX + (e.clientX - panStartX);
  panY = panStartPY + (e.clientY - panStartY);
  updateTransform();
});

window.addEventListener('mouseup', () => {
  // End island drag
  if (isDragging) {
    const el = dragIsland && svg.querySelector('.island-group[data-id="' + dragIsland.id + '"]');
    if (el) {
      el.classList.remove('dragging');
      if (dragMoved) el.classList.add('snap-placed');
      setTimeout(() => el && el.classList.remove('snap-placed'), 400);
    }
    if (dragMoved) {
      saveLayout();
      updateMinimap();
    }
    isDragging = false;
    dragIsland = null;
    container.classList.remove('grabbing');
    return;
  }
  isPanning = false;
  container.classList.remove('grabbing');
});

container.addEventListener('wheel', e => {
  e.preventDefault();
  const rect = container.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  const worldBefore = screenToWorld(mx, my);

  const zoomFactor = e.deltaY < 0 ? 1.12 : 1 / 1.12;
  scale = Math.max(0.15, Math.min(8, scale * zoomFactor));

  const worldAfter = screenToWorld(mx, my);
  panX += (worldAfter.x - worldBefore.x) * scale;
  panY += (worldAfter.y - worldBefore.y) * scale;

  updateTransform();
}, {passive: false});

// Touch support
let lastTouchDist = 0;
let lastTouchX = 0, lastTouchY = 0;

container.addEventListener('touchstart', e => {
  if (e.touches.length === 1) {
    // Check if touching an island in edit mode
    if (editMode) {
      const el = document.elementFromPoint(e.touches[0].clientX, e.touches[0].clientY);
      const islandEl = el && el.closest && el.closest('.island-group');
      if (islandEl) {
        const id = islandEl.getAttribute('data-id');
        const isl = islands.find(i => i.id === id);
        if (isl) {
          isDragging = true;
          dragIsland = isl;
          dragStartMX = e.touches[0].clientX;
          dragStartMY = e.touches[0].clientY;
          dragOrigX = isl.x;
          dragOrigY = isl.y;
          dragMoved = false;
          islandEl.classList.add('dragging');
          return;
        }
      }
    }
    isPanning = true;
    panStartX = e.touches[0].clientX;
    panStartY = e.touches[0].clientY;
    panStartPX = panX;
    panStartPY = panY;
  } else if (e.touches.length === 2) {
    isPanning = false;
    isDragging = false;
    const dx = e.touches[1].clientX - e.touches[0].clientX;
    const dy = e.touches[1].clientY - e.touches[0].clientY;
    lastTouchDist = Math.sqrt(dx * dx + dy * dy);
    lastTouchX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
    lastTouchY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
  }
}, {passive: true});

container.addEventListener('touchmove', e => {
  e.preventDefault();
  // Touch drag
  if (isDragging && dragIsland && e.touches.length === 1) {
    const dx = (e.touches[0].clientX - dragStartMX) / scale;
    const dy = (e.touches[0].clientY - dragStartMY) / scale;
    if (Math.abs(dx) > 2 || Math.abs(dy) > 2) dragMoved = true;
    if (dragMoved) {
      dragIsland.x = dragOrigX + dx;
      dragIsland.y = dragOrigY + dy;
      const el = svg.querySelector('.island-group[data-id="' + dragIsland.id + '"]');
      if (el) el.setAttribute('transform', 'translate(' + dragIsland.x + ',' + dragIsland.y + ')');
      rebuildBridges();
    }
    return;
  }
  if (e.touches.length === 1 && isPanning) {
    panX = panStartPX + (e.touches[0].clientX - panStartX);
    panY = panStartPY + (e.touches[0].clientY - panStartY);
    updateTransform();
  } else if (e.touches.length === 2) {
    const dx = e.touches[1].clientX - e.touches[0].clientX;
    const dy = e.touches[1].clientY - e.touches[0].clientY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (lastTouchDist > 0) {
      const factor = dist / lastTouchDist;
      scale = Math.max(0.15, Math.min(8, scale * factor));
      updateTransform();
    }
    lastTouchDist = dist;
  }
}, {passive: false});

container.addEventListener('touchend', () => {
  if (isDragging) {
    const el = dragIsland && svg.querySelector('.island-group[data-id="' + dragIsland.id + '"]');
    if (el) { el.classList.remove('dragging'); }
    if (dragMoved) { saveLayout(); updateMinimap(); }
    isDragging = false;
    dragIsland = null;
  }
  isPanning = false;
  lastTouchDist = 0;
});

// Zoom controls
document.getElementById('zoomIn').addEventListener('click', () => {
  scale = Math.min(8, scale * 1.3);
  updateTransform();
});
document.getElementById('zoomOut').addEventListener('click', () => {
  scale = Math.max(0.15, scale / 1.3);
  updateTransform();
});
document.getElementById('zoomReset').addEventListener('click', () => {
  scale = 0.55; panX = 0; panY = 0;
  updateTransform();
});

// Close panel
document.getElementById('dp-close').addEventListener('click', () => {
  detailPanel.classList.remove('open');
  selectedIsland = null;
});

// Click background to close panel
container.addEventListener('click', e => {
  if (!e.target.closest('.island-group') && !isPanning) {
    detailPanel.classList.remove('open');
    selectedIsland = null;
  }
});

// Keyboard
document.addEventListener('keydown', e => {
  if (e.key === 'Escape') {
    detailPanel.classList.remove('open');
    selectedIsland = null;
  } else if (e.key === '+' || e.key === '=') {
    scale = Math.min(8, scale * 1.2);
    updateTransform();
  } else if (e.key === '-') {
    scale = Math.max(0.15, scale / 1.2);
    updateTransform();
  } else if (e.key === '0') {
    scale = 0.55; panX = 0; panY = 0;
    updateTransform();
  }
});

// Minimap click to navigate
document.getElementById('minimap').addEventListener('click', e => {
  const rect = e.currentTarget.getBoundingClientRect();
  const mx = (e.clientX - rect.left) / rect.width;
  const my = (e.clientY - rect.top) / rect.height;
  const mapMinX = -1150, mapMaxX = 1200, mapMinY = -750, mapMaxY = 950;
  const worldX = mapMinX + mx * (mapMaxX - mapMinX);
  const worldY = mapMinY + my * (mapMaxY - mapMinY);
  panX = -worldX * scale;
  panY = -worldY * scale;
  updateTransform();
});

// Search
document.getElementById('searchInput').addEventListener('input', e => {
  const q = e.target.value.toLowerCase().trim();
  if (q.length < 2) return;
  const match = islands.find(i => i.name.toLowerCase().includes(q) || i.id.includes(q));
  if (match) {
    showToast('Hittade: ' + match.emoji + ' ' + match.name);
  }
});
document.getElementById('searchInput').addEventListener('keydown', e => {
  if (e.key === 'Enter') {
    const q = e.target.value.toLowerCase().trim();
    const match = islands.find(i => i.name.toLowerCase().includes(q) || i.id.includes(q));
    if (match) {
      // Navigate to island
      panX = -match.x * scale;
      panY = -match.y * scale;
      updateTransform();
      selectIsland(match);
    } else {
      showToast('Ingen tr\u00e4ff f\u00f6r "' + e.target.value + '"');
    }
  }
});

// ========== TOOLBAR ==========
document.getElementById('btnNavigate').addEventListener('click', () => setEditMode(false));
document.getElementById('btnArrange').addEventListener('click', () => setEditMode(true));
document.getElementById('btnResetLayout').addEventListener('click', () => {
  if (confirm('Vill du Ã¥terstÃ¤lla alla Ã¶ar till sina originalpositioner?')) {
    resetLayout();
  }
});

// ========== TABLE VIEW ==========
const tableColumns = [
  {key:'name',    label:'Webbplats',    sortFn: (a,b) => a.name.localeCompare(b.name, 'sv')},
  {key:'template',label:'Webbplatstyp', sortFn: (a,b) => {const sa=COMM_SITES.has(a.id)?1:0, sb=COMM_SITES.has(b.id)?1:0; return sa-sb;}},
  {key:'type',    label:'Roll',         sortFn: (a,b) => a.type.localeCompare(b.type)},
  {key:'group',   label:'Grupp',        sortFn: (a,b) => (a.hubId||a.id).localeCompare(b.hubId||b.id)},
  {key:'docs',    label:'Dokument',     sortFn: (a,b) => a.docs - b.docs},
  {key:'libs',    label:'Bibliotek',    sortFn: (a,b) => a.libs.length - b.libs.length},
  {key:'activity',label:'Aktivitet',    sortFn: (a,b) => {const o={high:3,medium:2,low:1}; return (o[a.activity]||0)-(o[b.activity]||0);}},
  {key:'visited', label:'BesÃ¶kt',       sortFn: (a,b) => (a.visited?1:0)-(b.visited?1:0)}
];
let tableSortCol = 'name';
let tableSortAsc = true;
let currentView = 'card'; // 'card' | 'map' | 'table'

function buildTableHead() {
  const tr = document.getElementById('table-head');
  tr.innerHTML = '';
  tableColumns.forEach(col => {
    const th = document.createElement('th');
    th.dataset.col = col.key;
    const arrow = tableSortCol === col.key ? (tableSortAsc ? ' \u25B2' : ' \u25BC') : ' \u25B4';
    th.innerHTML = col.label + '<span class="sort-arrow">' + arrow + '</span>';
    if (tableSortCol === col.key) th.classList.add('sorted');
    th.addEventListener('click', () => {
      if (tableSortCol === col.key) { tableSortAsc = !tableSortAsc; }
      else { tableSortCol = col.key; tableSortAsc = true; }
      buildTableHead();
      renderTableBody();
    });
    tr.appendChild(th);
  });
}

function renderTableBody() {
  const tbody = document.getElementById('table-body');
  tbody.innerHTML = '';
  const col = tableColumns.find(c => c.key === tableSortCol);
  const sorted = [...islands].sort((a, b) => {
    const r = col.sortFn(a, b);
    return tableSortAsc ? r : -r;
  });
  const typeLabels = {hub:'Hub',satellite:'Satellit',dept:'Avdelning',project:'Projekt'};
  const actLabels = {high:'HÃ¶g',medium:'Medel',low:'LÃ¥g'};
  const actColors = {high:'#50bb4e',medium:'#e8b020',low:'#888'};
  const hubMap = {};
  islands.forEach(i => { if (i.type === 'hub') hubMap[i.id] = i; });

  sorted.forEach(isl => {
    const tr = document.createElement('tr');
    const isComm = COMM_SITES.has(isl.id);
    // Name
    const tdName = document.createElement('td');
    tdName.className = 'name-cell';
    tdName.textContent = isl.name;
    tr.appendChild(tdName);
    // Site template
    const tdTpl = document.createElement('td');
    if (isComm) {
      tdTpl.innerHTML = '<span class="type-badge" style="background:rgba(212,168,67,.15);color:var(--gold);border:1px solid rgba(212,168,67,.3)">\u{1F4E1} Kommunikation</span>';
    } else {
      tdTpl.innerHTML = '<span class="type-badge" style="background:rgba(80,140,200,.15);color:#8ac;border:1px solid rgba(80,140,200,.3)">\u{1F465} Grupp (Team)</span>';
    }
    tr.appendChild(tdTpl);
    // Role/Type
    const tdType = document.createElement('td');
    tdType.innerHTML = '<span class="type-badge ' + isl.type + '">' + (typeLabels[isl.type]||isl.type) + '</span>';
    tr.appendChild(tdType);
    // Group (hub name)
    const tdGroup = document.createElement('td');
    const hub = isl.hubId ? hubMap[isl.hubId] : null;
    tdGroup.textContent = isl.type === 'hub' ? '(egen hub)' : hub ? hub.name : '\u2014';
    tdGroup.style.color = hub ? 'rgba(255,255,255,.7)' : 'rgba(255,255,255,.35)';
    tr.appendChild(tdGroup);
    // Docs
    const tdDocs = document.createElement('td');
    tdDocs.textContent = String(isl.docs);
    tdDocs.style.fontVariantNumeric = 'tabular-nums';
    tr.appendChild(tdDocs);
    // Libs
    const tdLibs = document.createElement('td');
    const libNames = isl.libs.map(l => l.n).join(', ');
    tdLibs.innerHTML = '<span style="color:var(--pk);font-weight:600;margin-right:6px">' + isl.libs.length + '</span><span class="libs-list">' + libNames + '</span>';
    tr.appendChild(tdLibs);
    // Activity
    const tdAct = document.createElement('td');
    tdAct.innerHTML = '<span class="activity-dot" style="background:' + (actColors[isl.activity]||'#888') + '"></span>' + (actLabels[isl.activity]||isl.activity);
    tr.appendChild(tdAct);
    // Visited
    const tdVis = document.createElement('td');
    tdVis.innerHTML = isl.visited
      ? '<span class="visited-badge yes">\u2713 Ja</span>'
      : '<span class="visited-badge no">Nej</span>';
    tr.appendChild(tdVis);

    // Click row to open detail panel + navigate on map
    tr.addEventListener('click', () => {
      selectIsland(isl);
      // Also center map on this island for when user switches back
      panX = -isl.x * scale;
      panY = -isl.y * scale;
      updateTransform();
    });
    tbody.appendChild(tr);
  });
  document.getElementById('table-count').textContent = sorted.length + ' webbplatser';
}

// ========== CARD VIEW: BUCKETS ==========
let cardBuckets = []; // [{id, name, color, siteIds:[]}]
const BUCKET_COLORS = ['#50bb4e','#4a9ab8','#d4a843','#a84a88','#e07040','#6a8aaa','#aa6a3a','#7a5ab8'];
let cardStarred = new Set();
let siteColors = {}; // {siteId: '#color'}
const CTX_SWATCHES = ['#50bb4e','#d4a843','#4a9ab8','#a84a88','#e07040','#6a8aaa','#c94040','#7a5ab8','#2aaa5a','#aa6a3a','#3a8aa8','#e0a030'];

function loadBuckets() {
  try {
    const raw = localStorage.getItem('dina-skargard-buckets');
    if (raw) cardBuckets = JSON.parse(raw);
  } catch(e) {}
  try {
    const raw = localStorage.getItem('dina-skargard-starred');
    if (raw) cardStarred = new Set(JSON.parse(raw));
  } catch(e) {}
  try {
    const raw = localStorage.getItem('dina-skargard-sitecolors');
    if (raw) siteColors = JSON.parse(raw);
  } catch(e) {}
}
function saveBuckets() {
  localStorage.setItem('dina-skargard-buckets', JSON.stringify(cardBuckets));
}
function saveStarred() {
  localStorage.setItem('dina-skargard-starred', JSON.stringify([...cardStarred]));
}

function saveSiteColors() {
  localStorage.setItem('dina-skargard-sitecolors', JSON.stringify(siteColors));
}

// ========== CONTEXT MENU ==========
let ctxTargetSiteId = null;
function showCardContextMenu(x, y, siteId) {
  ctxTargetSiteId = siteId;
  const menu = document.getElementById('card-ctx-menu');
  const colorsDiv = document.getElementById('ctx-colors');
  colorsDiv.innerHTML = '';
  CTX_SWATCHES.forEach(color => {
    const swatch = document.createElement('div');
    swatch.className = 'ctx-swatch' + (siteColors[siteId] === color ? ' active' : '');
    swatch.style.background = color;
    swatch.addEventListener('click', (e) => {
      e.stopPropagation();
      siteColors[siteId] = color;
      saveSiteColors();
      menu.classList.remove('open');
      renderBuckets();
      renderCardGrid();
    });
    colorsDiv.appendChild(swatch);
  });
  // Position menu
  menu.style.left = Math.min(x, window.innerWidth - 180) + 'px';
  menu.style.top = Math.min(y, window.innerHeight - 200) + 'px';
  menu.classList.add('open');
}
document.getElementById('ctx-clear').addEventListener('click', () => {
  if (ctxTargetSiteId) {
    delete siteColors[ctxTargetSiteId];
    saveSiteColors();
    document.getElementById('card-ctx-menu').classList.remove('open');
    renderBuckets();
    renderCardGrid();
  }
});
// Close context menu on click elsewhere
document.addEventListener('click', () => {
  document.getElementById('card-ctx-menu').classList.remove('open');
});

function addBucket() {
  const id = 'b' + Date.now();
  const color = BUCKET_COLORS[cardBuckets.length % BUCKET_COLORS.length];
  cardBuckets.push({id, name:'Ny kategori', color, siteIds:[]});
  saveBuckets();
  renderBuckets();
  renderCardGrid();
}
function deleteBucket(bid) {
  cardBuckets = cardBuckets.filter(b => b.id !== bid);
  saveBuckets();
  renderBuckets();
  renderCardGrid();
}
function renameBucket(bid, name) {
  const b = cardBuckets.find(b => b.id === bid);
  if (b) { b.name = name; saveBuckets(); }
}

function bucketForSite(siteId) {
  return cardBuckets.find(b => b.siteIds.includes(siteId));
}
function removeSiteFromBuckets(siteId) {
  cardBuckets.forEach(b => { b.siteIds = b.siteIds.filter(s => s !== siteId); });
}

function renderBuckets() {
  const list = document.getElementById('bucket-list');
  list.innerHTML = '';
  cardBuckets.forEach(bucket => {
    const el = document.createElement('div');
    el.className = 'bucket';
    el.dataset.bid = bucket.id;

    // Header
    const header = document.createElement('div');
    header.className = 'bucket-header';
    const dot = document.createElement('div');
    dot.className = 'bucket-color';
    dot.style.background = bucket.color;
    header.appendChild(dot);
    const nameInput = document.createElement('input');
    nameInput.className = 'bucket-name';
    nameInput.value = bucket.name;
    nameInput.addEventListener('change', () => renameBucket(bucket.id, nameInput.value));
    header.appendChild(nameInput);
    const countSpan = document.createElement('span');
    countSpan.className = 'bucket-count';
    countSpan.textContent = bucket.siteIds.length + ' st';
    header.appendChild(countSpan);
    const delBtn = document.createElement('button');
    delBtn.className = 'bucket-del';
    delBtn.textContent = '\u00d7';
    delBtn.title = 'Ta bort kategori';
    delBtn.addEventListener('click', (e) => { e.stopPropagation(); deleteBucket(bucket.id); });
    header.appendChild(delBtn);
    el.appendChild(header);

    // Cards area (full-size cards)
    const cardsArea = document.createElement('div');
    cardsArea.className = 'bucket-cards';
    const actColors = {high:'#50bb4e', medium:'#e8b020', low:'#bbb'};
    const typeLabels = {hub:'Hub', satellite:'Satellit', dept:'Avdelning', project:'Projekt'};
    if (bucket.siteIds.length === 0) {
      const empty = document.createElement('div');
      empty.className = 'bucket-empty';
      empty.textContent = 'Dra kort hit...';
      cardsArea.appendChild(empty);
    }
    bucket.siteIds.forEach(sid => {
      const isl = islands.find(i => i.id === sid);
      if (!isl) return;
      const card = buildSiteCard(isl, actColors, typeLabels);
      cardsArea.appendChild(card);
    });
    el.appendChild(cardsArea);

    // Drop zone
    el.addEventListener('dragover', (e) => { e.preventDefault(); el.classList.add('drag-over'); });
    el.addEventListener('dragenter', (e) => { e.preventDefault(); el.classList.add('drag-over'); });
    el.addEventListener('dragleave', (e) => {
      if (!el.contains(e.relatedTarget)) el.classList.remove('drag-over');
    });
    el.addEventListener('drop', (e) => {
      e.preventDefault();
      el.classList.remove('drag-over');
      const sid = e.dataTransfer.getData('text/plain');
      if (sid) {
        removeSiteFromBuckets(sid);
        bucket.siteIds.push(sid);
        saveBuckets();
        renderBuckets();
        renderCardGrid();
      }
    });

    list.appendChild(el);
  });
}

function typeColor(type) {
  return type === 'hub' ? '#d4a843' : type === 'satellite' ? '#50bb4e' : type === 'project' ? '#a84a88' : '#4a9ab8';
}

function renderCardGrid() {
  const grid = document.getElementById('card-grid');
  grid.innerHTML = '';
  const query = (document.getElementById('cardSearch').value || '').toLowerCase().trim();
  const actColors = {high:'#50bb4e', medium:'#e8b020', low:'#bbb'};
  const typeLabels = {hub:'Hub', satellite:'Satellit', dept:'Avdelning', project:'Projekt'};

  // Sites NOT in any bucket
  const bucketed = new Set();
  cardBuckets.forEach(b => b.siteIds.forEach(s => bucketed.add(s)));

  let list = islands.filter(isl => !bucketed.has(isl.id));

  // Search filter
  if (query.length >= 2) {
    list = list.filter(isl =>
      isl.name.toLowerCase().includes(query) ||
      isl.id.includes(query) ||
      (isl.type && isl.type.includes(query)) ||
      (isl.group && isl.group.includes(query)) ||
      (isl.desc && isl.desc.toLowerCase().includes(query))
    );
  }

  // Sort: starred first, then hubs, then alpha
  list.sort((a, b) => {
    const sa = cardStarred.has(a.id) ? 0 : 1;
    const sb = cardStarred.has(b.id) ? 0 : 1;
    if (sa !== sb) return sa - sb;
    const ta = a.type === 'hub' ? 0 : 1;
    const tb = b.type === 'hub' ? 0 : 1;
    if (ta !== tb) return ta - tb;
    return a.name.localeCompare(b.name, 'sv');
  });

  if (list.length === 0 && query.length >= 2) {
    const noRes = document.createElement('div');
    noRes.className = 'card-no-results';
    noRes.textContent = 'Inga webbplatser matchar "' + query + '"';
    grid.appendChild(noRes);
  }

  list.forEach(isl => {
    const card = buildSiteCard(isl, actColors, typeLabels);
    grid.appendChild(card);
  });

  const total = islands.length;
  const showing = list.length + bucketed.size;
  document.getElementById('card-count').textContent = showing + ' av ' + total + ' webbplatser';
}

function buildSiteCard(isl, actColors, typeLabels) {
  const card = document.createElement('div');
  const customColor = siteColors[isl.id];
  card.className = 'site-card' + (customColor ? ' has-custom-color' : '');
  card.draggable = true;
  card.dataset.id = isl.id;

  // Custom color bar (shown if user assigned a color)
  const colorBar = document.createElement('div');
  colorBar.className = 'card-color-bar';
  if (customColor) colorBar.style.background = customColor;
  card.appendChild(colorBar);

  // Type stripe (hidden when custom color active)
  const stripe = document.createElement('div');
  stripe.className = 'card-stripe ' + isl.type;
  card.appendChild(stripe);

  // Body
  const body = document.createElement('div');
  body.className = 'card-body';

  // Top: initials + info
  const top = document.createElement('div');
  top.className = 'card-top';
  const initials = document.createElement('div');
  initials.className = 'card-initials ' + isl.type;
  const parts = isl.name.split(/[\s&]+/);
  initials.textContent = parts.length >= 2
    ? (parts[0][0] + parts[1][0]).toUpperCase()
    : isl.name.substring(0, 2).toUpperCase();
  top.appendChild(initials);

  const info = document.createElement('div');
  info.className = 'card-info';
  const nameEl = document.createElement('div');
  nameEl.className = 'card-name';
  nameEl.textContent = isl.name;
  info.appendChild(nameEl);
  const tplEl = document.createElement('div');
  tplEl.className = 'card-template';
  tplEl.textContent = COMM_SITES.has(isl.id) ? 'Kommunikationswebbplats' : 'Gruppwebbplats';
  info.appendChild(tplEl);
  const badge = document.createElement('span');
  badge.className = 'card-type-badge ' + isl.type;
  badge.textContent = typeLabels[isl.type] || isl.type;
  info.appendChild(badge);
  top.appendChild(info);
  body.appendChild(top);

  // Star
  const star = document.createElement('button');
  star.className = 'card-star' + (cardStarred.has(isl.id) ? ' starred' : '');
  star.textContent = cardStarred.has(isl.id) ? '\u2605' : '\u2606';
  star.addEventListener('click', (e) => {
    e.stopPropagation();
    if (cardStarred.has(isl.id)) { cardStarred.delete(isl.id); }
    else { cardStarred.add(isl.id); }
    saveStarred();
    renderBuckets();
    renderCardGrid();
  });
  card.appendChild(star);

  // Stats row
  const stats = document.createElement('div');
  stats.className = 'card-stats';

  // Docs stat
  const docStat = document.createElement('div');
  docStat.className = 'card-stat';
  docStat.innerHTML = '<span class="stat-icon">\u{1F4C4}</span><span class="stat-val">' + isl.docs + '</span> dok';
  stats.appendChild(docStat);

  // Users stat
  const usrStat = document.createElement('div');
  usrStat.className = 'card-stat';
  usrStat.innerHTML = '<span class="stat-icon">\u{1F465}</span><span class="stat-val">' + (isl.users || 0) + '</span> anv';
  stats.appendChild(usrStat);

  // Libs stat with hover tooltip
  const libStat = document.createElement('div');
  libStat.className = 'card-stat has-tooltip';
  libStat.innerHTML = '<span class="stat-icon">\u{1F4C1}</span><span class="stat-val">' + isl.libs.length + '</span> bib';

  const tooltip = document.createElement('div');
  tooltip.className = 'lib-tooltip';
  isl.libs.forEach(lib => {
    const item = document.createElement('div');
    item.className = 'lt-item';
    item.innerHTML = '<span class="lt-dot"></span>' + lib.n + '<span class="lt-count">' + lib.c + ' dok</span>';
    tooltip.appendChild(item);
  });
  libStat.appendChild(tooltip);
  stats.appendChild(libStat);

  body.appendChild(stats);
  card.appendChild(body);

  // Activity dot
  const actDot = document.createElement('div');
  actDot.className = 'card-activity';
  actDot.style.background = actColors[isl.activity] || '#bbb';
  actDot.title = 'Aktivitet: ' + (isl.activity === 'high' ? 'H\u00f6g' : isl.activity === 'medium' ? 'Medel' : 'L\u00e5g');
  card.appendChild(actDot);

  // Click
  card.addEventListener('click', () => selectIsland(isl));

  // Right-click: show color menu
  card.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    showCardContextMenu(e.clientX, e.clientY, isl.id);
  });

  // Drag
  card.addEventListener('dragstart', (e) => {
    e.dataTransfer.setData('text/plain', isl.id);
    card.classList.add('dragging');
  });
  card.addEventListener('dragend', () => card.classList.remove('dragging'));

  return card;
}

// ========== VIEW SWITCHING ==========
function switchView(view) {
  currentView = view;
  document.body.classList.remove('view-table', 'view-card');
  document.getElementById('table-view').classList.remove('active');
  document.getElementById('card-view').classList.remove('active');
  ['btnCardView','btnMapView','btnTableView'].forEach(id =>
    document.getElementById(id).classList.remove('active'));

  if (view === 'card') {
    document.body.classList.add('view-card');
    document.getElementById('card-view').classList.add('active');
    document.getElementById('btnCardView').classList.add('active');
    renderBuckets();
    renderCardGrid();
  } else if (view === 'table') {
    document.body.classList.add('view-table');
    document.getElementById('table-view').classList.add('active');
    document.getElementById('btnTableView').classList.add('active');
    buildTableHead();
    renderTableBody();
  } else {
    document.getElementById('btnMapView').classList.add('active');
  }
}

document.getElementById('btnCardView').addEventListener('click', () => switchView('card'));
document.getElementById('btnMapView').addEventListener('click', () => switchView('map'));
document.getElementById('btnTableView').addEventListener('click', () => switchView('table'));

// Card search
document.getElementById('cardSearch').addEventListener('input', () => renderCardGrid());

// Add bucket button
document.getElementById('addBucketBtn').addEventListener('click', () => addBucket());

// Card grid drop zone (remove from bucket)
document.getElementById('card-grid').addEventListener('dragover', (e) => e.preventDefault());
document.getElementById('card-grid').addEventListener('drop', (e) => {
  e.preventDefault();
  const sid = e.dataTransfer.getData('text/plain');
  if (sid) {
    removeSiteFromBuckets(sid);
    saveBuckets();
    renderBuckets();
    renderCardGrid();
  }
});

// ========== INIT ==========
// Load saved layout before building map
const hadSaved = loadLayout();
loadBuckets();
buildMap();
addAnimations();
updateMinimap();
if (hadSaved) showToast('Din sparade layout har laddats');

// Default to card view
switchView('card');

// Handle resize
window.addEventListener('resize', () => {
  updateTransform();
});

</script>
</body>
</html>
